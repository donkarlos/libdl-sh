#! /bin/sh
#-----------------------------------------------------------------------------
#   gensubst			- Generate substitutions
#
#   Copyright (C) 2013-2016 Das Computerlabor (DCl-M)
#
#   This library is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public License
#   as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public License
#   along with this library; if not, write to the Free Software Founda-
#   tion, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
##
##  AUTHOR(S):	ks	Karl Schmitz <ks@computerlabor.org>
##
##  WRITTEN BY:	ks	2013-02-12
##  CHANGED BY:	ks	2013-03-09	Move script comment stripping to
##					`auto/gensubst.sed'.
##		ks	2013-04-17	Fix and optimize template extraction.
##					Allow to tune the finishing mechanism
##					with $(FINISH_ANTE/POST_SEDFLAGS).
##		ks	2016-05-27	Add 'pathname' substitution.
##		ks	2016-05-28	Divide processing into phases.
##					Split 'pathname' substitution in two
##					phases.
##					Add 'templates' substitution.
##		ks	2016-05-29	Add 're' and 'rs' substitutions.
##					Fix RE quoting in phase 4.
##					Add 'FINISH_SEDFLAGS' substitution.
##					Drop 'FINISH' substitution.
##		ks	2016-05-30	Eliminate direct RS quoting.
##					Add 'get' substitution.
##					Add (universal) 'quote' substitution.
##					Use that to fix RE/RS quoting in
##					'FINISH_SEDFLAGS' substitution.
##					Make empty 'get' result disappear.
##		ks	2016-06-07	Bootstrap gensubst.
##					Add multi-line support to 'get' subst.
##					Make template head and foot tunable.
##		ks	2016-06-08	Get independent of config.sh.
##----------------------------------------------------------------------------
##  Initialization:
#-----------------------------------------------------------------------------
LC_ALL=C; export LC_ALL			## Avoid locale insanities.

BS=\\ SQ=\' NL='
'					## Used for proper quoting.
eval `sed '
    s/='"$SQ"'@[^@'"$SQ"'=]*@'"$SQ"'//;s/\('"$SQ"'\)=.*$/\1/;s/$/;/
' <<\EOF
    SED='@SED@'=sed
    srcdir='@srcdir@'=
EOF`					## Expand required output variables.

cs_upper=ABCDEFGHIJKLMNOPQRSTUVWXYZ	## Construct upper/lower-case letter,
cs_lower=abcdefghijklmnopqrstuvwxyz	## decimal digit, letter, and alpha-
cs_digit=0123456789			## numeric character sets.
cs_alpha=$cs_upper$cs_lower
cs_alnum=$cs_alpha$cs_digit

re_ident="[_$cs_alpha][_$cs_alnum]*"	## Define RE for IDENTifiers.
thead=@					## (Pre-)define templates' (literal)
tfoot=@					## head and foot.
shead='$('				## (Pre-)define substitutions' (lite-
sfoot=')'				## ral) head and foot.

ex_vn='_\('"$re_ident"'\)='		## Define expr(1) REs for splitting
ex_vv='[^=]*=\(.*\)$'			## NAME=VALUE into NAME and VALUE.

##----------------------------------------------------------------------------
##  Phase 1: Check if SUBSTitution is specified and valid
##----------------------------------------------------------------------------
if test $# -gt 0; then			## SUBSTitution specified?
    subst=$1; shift			## Yes, fetch it.
    case $subst in			## Is it valid?
	get|re|rs|quote|pathname|templates|FINISH_SEDFLAGS)
	    vns=-			## Yes, start with empty NAME list.
	    ;;
	*)  echo "$0 $subst: unknown SUBSTitution!" >&2
	    subst=usage			## No, complain and finally show
	    ;;				## usage.
    esac
else					## No substitution given.
    echo "$0: need SUBSTitution!" >&2
    subst=usage				## Complain and finally show usage.
fi

##----------------------------------------------------------------------------
##  Phase 2: Process 'NAME=VALUE' parameters
##----------------------------------------------------------------------------
while test $# -gt 0; do
    case $1 in
	*=*)				## Looking at 'NAME=VALUE'?
	    if vn=`expr "_$1" : "$ex_vn"`; then
					## Yes, and NAME is an identifier?
		vv=`expr "$1" : "$ex_vv"`
		eval "_$vn"'=$vv'; vns=$vns$vn-
					## Yes, get VALUE and set variable.
	    else
		echo "$0 $subst $1: malformed NAME=VALUE!" >&2
		subst=usage; break	## No, complain and finally show
	    fi				## usage.
	    ;;
	*)  break			## No, assume it's an UNFINISHED.
	    ;;
    esac; shift
done

##----------------------------------------------------------------------------
##  Phase 3: Apply 'prefix=PREFIX' and/or 'suffix=SUFFIX' to UNFINISHEDs
##----------------------------------------------------------------------------
case $subst in				## Phase applies to SUBSTitution?
    pathname|templates|FINISH_SEDFLAGS)	## Yes...
	case $# in			## UNFINISHEDs specified?
	    0)	;;			## No, we're already done.
	    *)  sx='s/$/ /;'		## Yes, start out sed(1) script.
		case $vns in		## 'suffix=SUFFIX' specified?
		    *-suffix-*)		## Yes, does it apply?
			case $_suffix in
			    ?*)	rs=`$0 rs "$_suffix"`
				sx="$sx"'s/ /'"$rs"' /g;'
				;;	## Yes, augment sed(1) script so that
			esac		## UNFINISHEDs are suffixed.
			;;
		esac
		sx="$sx"'s/ $//;s/^/ /;'
		case $vns in		## 'prefix=PREFIX' specified?
		    *-prefix-*)		## Yes, does it apply?
			case $_prefix in
			    ?*)	rs=`$0 rs "$_prefix"`
				sx="$sx"'s/ / '"$rs"'/g;'
				;;	## Yes, augment sed(1) script so that
			esac		## UNFINISHEDs are prefixed.
			;;
		esac
		sx="$sx"':1'"$NL"'s/\([ /]\)\.\//\1/;t1'"$NL"':2'"$NL"
		sx="$sx"'s/\( \.\.\/\(\.\.\/\)*\([^/ ][^/ ]*\/\)*\)[^./ ][^/ ]*\/\.\.\//\1/;t2'"$NL"
		sx="$sx"'s/\( \.\.\/\(\.\.\/\)*\([^/ ][^/ ]*\/\)*\)\.[^./ ][^/ ]*\/\.\.\//\1/;t2'"$NL"
		sx="$sx"'s/^ //'
		set shiftee `echo $* | $SED "$sx"`; shift
		;;			## Yes, rewrite UNFINISHEDs.
	esac
	;;
esac

##----------------------------------------------------------------------------
##  Phase 4: Extract templates
##----------------------------------------------------------------------------
case $subst in				## Phase applies to SUBSTitution?
    templates|FINISH_SEDFLAGS)		## Yes...
	case $vns in			## 'template=TEMPLATE' specified?
	    *-template-*)		## Yes, extract templates' head/foot.
		thead=`expr "_$_template" : '_\([^_'"$cs_alnum"']*\)'`
		tfoot=`expr "_$_template" : '_[^_'"$cs_alnum"']*'"$re_ident"'\([^_'"$cs_alnum"']*\)$'`
		;;
	esac
	re_thead=`$0 re "$thead"`	## RE-quote templates' head and foot.
	re_tfoot=`$0 re "$tfoot"`
	set shiftee `{
	    $SED '
		:1
		/'"$re_thead$re_ident$re_tfoot"'/!d;h
		s/\('"$re_thead$re_ident"'\)'"$re_tfoot"'.*$/\1/
		s/^.*'"$re_thead"'\('"$re_ident"'\)$/\1/p;g
		s/'"$re_thead$re_ident$re_tfoot"'//;b1
	    ' ${1+"$@"} </dev/null 2>&0 ||
		echo "$0 $subst: Update your AF_FINISH_FILES() invocation!" >&2
	} | sort | uniq`; shift		## Extract names of templates occuring
					## in UNFINISHEDs, unify them, and re-
					## place UNFINISHEDs with template
					## names.
	case $# in			## UNFINISHEDs contained templates?
	    0)	echo "$0 $subst: No templates found. Do you still need me?" >&2
		exit 0			## No, show warning and exit with suc-
		;;			## cess (as no more phases apply).
	esac
	;;
esac

##----------------------------------------------------------------------------
##  Phase 5: Generate substitution
##----------------------------------------------------------------------------
case $subst in				## Which substitution?
    get)				## 'get' NAME [VALUE]...
	$SED '
	    /^'"$1"' *= */!d;s///;:1
	    /\\$/!{;y/	/ /;s/   */ /g;s/ $//;/^$/d;q;};N;s/\\\'"$NL"'/ /;t1
	' Makefile - <<EOF 2>/dev/null
$1=$2
EOF
					## Get NAME's value from 1st assign-
					## ment in top-level Makefile (or sup-
	;;				## ply default VALUE instead).
    re)					## 're' STRING [DELIMITER=/]...
	$SED '/^$/d;s/[]'"${2-/}"'^\.*$[]/'"$BS$BS"'&/g' <<EOF
$1
EOF
					## (RE,DELIMITER)-quote STRING (i.e.,
					## quote for use as match in sed(1)
	;;				## 's///' command with DELIMITER).
    rs)					## 'rs' STRING [DELIMITER=/]...
	$SED '/^$/d;s/[\&'"${2-/}"']/'"$BS$BS"'&/g' <<EOF
$1
EOF
					## (RS,DELIMITER)-quote STRING (i.e.,
					## quote for use as subst. in sed(1)
	;;				## 's///' command with DELIMITER).
    quote)				## 'quote' STRING ...
	case $#/${1-} in		## STRING specified?
	    [01]/)			## None or empty...
		;;			## We're done.
	    1/?*)			## Non-empty, no (OP,DELIMITER) pair...
		echo "$1"		## Emit STRING literally.
		;;
	    *)				## Non-empty, (OP,DELIMITER) pairs...
		qs=$1; set shiftee ${1+"$@"}
					## Initialize result and let following
					## 'shift 2' succeed.
		while shift 2; do	## Foreach OP/DELIMITER pair do...
		    case $#/$1 in
			[12]/r[es])     # Last valid pair?
			    $0 $1 "$qs" "${2-/}"
			    break	## Emit (OP,DELIMITER)-quoted result.
			    ;;
			[12]/*)		## Last pair?
			    echo "$qs"	## Emit result.
			    break
			    ;;
			*/r[es])	## Valid pair?
			    qs=`$0 $1 "$qs" "${2-/}"`
			    ;;		## (OP,DELIMITER)-quote result.
		    esac
		done
		;;
	esac
	;;
    pathname|templates)			## 'pathname'/'templates'...
	echo ${1+"$@"}			## Emit result (i.e., rewritten UNFI-
	;;				## NISHEDs or extr. template names.
    FINISH_SEDFLAGS)			## 'FINISH_SEDFLAGS'...
	rs_thead=`$0 quote "$thead" re '|' rs`
	rs_tfoot=`$0 quote "$tfoot" re '|' rs`
					## (RS,/)-quote (RE,|)-quoted template
					## head and foot.
	rs_shead=`$0 quote "$shead" rs '|' rs`
	rs_sfoot=`$0 quote "$sfoot" rs '|' rs`
					## (RS,/)-quote (RS,|)-quoted substi-
					## tution head and foot.
	gensubst_sed=`$SED 's/[^/][^/]*$/gensubst.sed/' <<EOF
$0
EOF`
	test -f "$gensubst_sed" || if test -f "$srcdir/$gensubst_sed"; then
	    gensubst_sed=$srcdir/$gensubst_sed
	else
	    echo "$0: $gensubst_sed: not found!" >&2; exit 1
	fi				## Try to auto-locate gensubst.sed...
	rs_gensubst_sed=`$0 rs "$gensubst_sed"`
					## ...and (RS,/)-quote its pathname.
	echo ${1+"$@"} | $SED '
	    s/$/ /
	    s/\([^ ][^ ]*\) /s|'"$rs_thead"'\1'"$rs_tfoot"'|'"$rs_shead"'\1'"$rs_sfoot"'|g;/g
	    s/;$/'"$SQ $rs_shead"'FINISH_POST_SEDFLAGS'"$rs_sfoot"'/
	    s/^/'"$rs_shead"'FINISH_ANTE_SEDFLAGS'"$rs_sfoot"' -f '"$rs_gensubst_sed"' -e '"$SQ"'/
	'				## Construct and emit result from quo-
	;;				## ted parts.
    usage)
	echo "Usage: $0 SUBST [NAME=VALUE ...] UNFINISHED ..." >&2
	exit 2
	;;
esac
