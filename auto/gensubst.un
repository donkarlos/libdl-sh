#! /bin/sh
#-----------------------------------------------------------------------------
#   gensubst			- Generate substitutions
#
#   Copyright (C) 2013-2017 Das Computerlabor (DCl-M)
#
#   This library is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public License
#   as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public License
#   along with this library; if not, write to the Free Software Founda-
#   tion, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
##
##  AUTHOR(S):	ks	Karl Schmitz <ks@computerlabor.org>
##
##  WRITTEN BY:	ks	2013-02-12
##  CHANGED BY:	ks	2013-03-09	Move script comment stripping to
##					`auto/gensubst.sed'.
##		ks	2013-04-17	Fix and optimize template extraction.
##					Allow to tune the finishing mechanism
##					with $(FINISH_ANTE/POST_SEDFLAGS).
##		ks	2016-05-27	Add 'pathname' substitution.
##		ks	2016-05-28	Divide processing into phases.
##					Add 'templates' substitution.
##		ks	2016-05-29	Add 'FINISH_SEDFLAGS' substitution.
##					Drop 'FINISH' substitution.
##		ks	2016-05-30	Add (universal) 'quote' substitution.
##		ks	2016-06-07	Bootstrap gensubst.
##					Make template head and foot tunable.
##		ks	2016-06-08	Get independent of config.sh.
##		ks	2016-06-09	Make makefile tunable.
##		ks	2016-06-10	Add 'expand' substitution.
##		ks      2016-06-14	Allow to override $(SED)/$(srcdir).
##		ks	2017-01-17	Update copyright.
##					Add 'substitute' substitution.
##----------------------------------------------------------------------------
##  Initialization:
#-----------------------------------------------------------------------------
LC_ALL=C; export LC_ALL			## Avoid locale insanities.

BQ=\` DQ=\" SQ=\' BS=\\ NL='
'					## Used for proper quoting.
cs_upper=ABCDEFGHIJKLMNOPQRSTUVWXYZ	## Construct upper/lower-case letter,
cs_lower=abcdefghijklmnopqrstuvwxyz	## decimal digit, letter, and alpha-
cs_digit=0123456789			## numeric character sets.
cs_alpha=$cs_upper$cs_lower
cs_alnum=$cs_alpha$cs_digit

re_ident="[_$cs_alpha][_$cs_alnum]*"	## Define RE for IDENTifiers.
shead='$('				## (Pre-)define substitutions' (lite-
sfoot=')'				## ral) head and foot.

ex_vn='_\('"$re_ident"'\)='		## Define expr(1) REs for splitting
ex_vv='[^=]*=\(.*\)$'			## NAME=VALUE into NAME and VALUE.

##----------------------------------------------------------------------------
##  Phase 1: Check if SUBSTitution is specified and valid
##----------------------------------------------------------------------------
case $# in				## SUBSTitution specified?
    0)	echo "$0: need SUBSTitution!" >&2
	subst=usage			## No, complain and show usage later.
	;;
    *)	subst=$1 vns=-			## Yes, fetch it and clear NAME list.
	case $subst in			## Valid SUBSTitution?
	    quote|pathname|templates|FINISH_SEDFLAGS|substitute|expand)
		_suffix= _prefix= _template="@${subst+_}@"
		_makefile=Makefile _mode=
		;;			## Yes, supply default settings.
	    *)	echo "$0 $subst: unknown SUBSTitution!" >&2
		subst=usage		## No, complain and show usage later.
		;;
	esac
	;;
esac

##----------------------------------------------------------------------------
##  Phase 2: Parse 'NAME=VALUE' parameters
##----------------------------------------------------------------------------
case $subst in
    usage)				## Phase applies to SUBSTitution?
	;;				## No, skip phase.
    *)	while shift; do			## Yes, foreach 'NAME=VALUE' do...
	    case $# in
		0)  break   ;;
	    esac; case $1 in
		*=*)			## Looking at 'NAME=VALUE'?
		    if vn=`expr "_$1" : "$ex_vn"`; then
					## Yes, and NAME is an identifier?
			vv=`expr "$1" : "$ex_vv"`
			eval "_$vn"'=$vv'; vns=$vns$vn-
					## Yes, get VALUE and set variable.
		    else
			echo "$0 $subst $1: malformed NAME=VALUE!" >&2
			subst=usage; break
		    fi			## No, complain and show usage later.
		    ;;
		--) shift; break	## No, assume UNFINISHEDs follow.
		    ;;
		*)  break		## No, assume it's an UNFINISHED.
		    ;;
	    esac
	done
	;;
esac

##----------------------------------------------------------------------------
##  Phase 3: Apply 'prefix=PREFIX' and/or 'suffix=SUFFIX' to UNFINISHEDs
##----------------------------------------------------------------------------
case $subst in				## Phase applies to SUBSTitution?
    pathname|templates|FINISH_SEDFLAGS|substitute)
					## Yes...
	case $vns in			## Configured sed(1) supplied?
	    *-SED-*)
		SED=$_SED	;;
	    *)	SED=`
		    $0 expand makefile="$_makefile" -- '$(SED)'
		` || SED=sed	;;
	esac; case $# in		## UNFINISHEDs specified?
	    0)	;;			## No, we're already done.
	    *)  sx='s/$/ /;'		## Yes, start out sed(1) script.
		case $_suffix in
		    ?*)	rs=`$0 quote SED="$SED" -- "$_suffix" rs`
			sx="$sx"'s/ /'"$rs"' /g;'
			;;		## Augment sed(1) script so that
		esac			## UNFINISHEDs are suffixed.
		sx="$sx"'s/ $//;s/^/ /;'
		case $_prefix in
		    ?*)	rs=`$0 quote SED="$SED" -- "$_prefix" rs`
			sx="$sx"'s/ / '"$rs"'/g;'
			;;		## Augment sed(1) script so that
		esac			## UNFINISHEDs are prefixed.
		sx="$sx"':1'"$NL"'s/\([ /]\)\.\//\1/;t1'"$NL"':2'"$NL"
		sx="$sx"'s/\( \.\.\/\(\.\.\/\)*\([^/ ][^/ ]*\/\)*\)[^./ ][^/ ]*\/\.\.\//\1/;t2'"$NL"
		sx="$sx"'s/\( \.\.\/\(\.\.\/\)*\([^/ ][^/ ]*\/\)*\)\.[^./ ][^/ ]*\/\.\.\//\1/;t2'"$NL"
		sx="$sx"'s/^ //'	## Augment sed(1) script with
					## './' and '../' optimization.
		set shiftee `$SED "$sx" <<EOF
$*
EOF`;		shift			## Yes, rewrite UNFINISHEDs.
		;;
	esac
	;;
esac

##----------------------------------------------------------------------------
##  Phase 4: Extract templates
##----------------------------------------------------------------------------
case $subst in				## Phase applies to SUBSTitution?
    templates|FINISH_SEDFLAGS|substitute)
					## Yes...
	thead=`expr "_$_template" : '_\([^_'"$cs_alnum"']*\)'`
	tfoot=`expr "_$_template" : '_[^_'"$cs_alnum"']*'"$re_ident"'\([^_'"$cs_alnum"']*\)$'`
	re_thead=`$0 quote SED="$SED" -- "$thead" re`
	re_tfoot=`$0 quote SED="$SED" -- "$tfoot" re`
					## Extract and (RE,'/')-quote
					## templates' head and foot.
	set shiftee `{
	    $SED '
		:1
		/'"$re_thead$re_ident$re_tfoot"'/!d;h
		s/\('"$re_thead$re_ident"'\)'"$re_tfoot"'.*$/\1/
		s/^.*'"$re_thead"'\('"$re_ident"'\)$/\1/p;g
		s/'"$re_thead$re_ident$re_tfoot"'//;b1
	    ' ${1+"$@"} </dev/null 2>&0 ||
		echo "$0 $subst: Update your AF_FINISH_FILES() invocation!" >&2
	} | sort | uniq`; shift		## Extract names of templates occuring
					## in UNFINISHEDs, unify them, and re-
					## place UNFINISHEDs with template
					## names.
	case $# in			## UNFINISHEDs contained templates?
	    0)	echo "$0 $subst: No templates found. Do you still need me?" >&2
		exit 0			## No, show warning and exit with suc-
		;;			## cess (as no more phases apply).
	esac
	;;
esac

##----------------------------------------------------------------------------
##  Phase 5: Generate substitution
##----------------------------------------------------------------------------
case $subst in				## Which substitution?
    quote)				## 'quote' QUOTEE [OP [DELIM]] ...
	case $vns in			## Configured sed(1) supplied?
	    *-SED-*)
		SED=$_SED	;;
	    *)	SED=`
		    $0 expand makefile="$_makefile" -- '$(SED)'
		` || SED=sed	;;
	esac; case $# in		## QUOTEE specified?
	    0)	quotee=; set shiftee;;	## No, assume it's empty.
	    *)	quotee=$1	    ;;	## Yes, fetch it.
	esac
	cs_shell=']^?*~! 	${}()<|>&;#'"$BQ$DQ$SQ$BS"'['
	sx_qre0='s/[]'	sx_qre1='^\.*$[]/'"$BS$BS"'&/g'
	sx_qrs0='s/[\&'	sx_qrs1=']/'"$BS$BS"'&/g'
	sx_qnl1=';s/'"$BS$NL"'/'"$BS$BS"'&/g'
	sx_qsh='s/'"$SQ"'/&'"$BS$BS"'&&/g;s/^/'"$SQ"'/;s/$/'"$SQ"'/'
					## Define sed(1) script particles.
	i=0; sx=':n'"$i$NL"'$!{;N;bn'"$i$NL"'}'
	while shift; do			## Foreach OP do...
	    case $# in			## All OPs processed?
		0)  $SED "$sx"';:p'"$i$NL"'/^$/d' <<EOF
$quotee
EOF
		    break		## Yes, finally quote QUOTEE.
		    ;;
	    esac; case $1 in		## No, which OP?
		re) sx="$sx$NL$sx_qre0${2-/}$sx_qre1$sx_qnl1"; ${2+shift}
		    ;;			## Apply (RE[,DELIM='/'])-quoting.
		rs) sx="$sx$NL$sx_qrs0${2-/}$sx_qrs1$sx_qnl1"; ${2+shift}
		    ;;			## Apply (RS[,DELIM='/'])-quoting.
		sh) sx="$sx"';:p'"$i"; i=`expr $i + 1`
		    sx="$sx$NL"'/^$/bq'"$i$NL"'/'"$BS$NL"'/bq'"$i"
		    sx="$sx$NL"'/['"$cs_shell"']/!bp'"$i$NL"':q'"$i$NL$sx_qsh"
		    ;;			## Apply (SH)-quoting.
	    esac
	done
	;;
    pathname|templates)			## 'pathname'/'templates'...
	echo ${1+"$@"}			## Emit result (i.e., rewritten UNFI-
	;;				## NISHEDs or extr. template names.
    FINISH_SEDFLAGS)			## 'FINISH_SEDFLAGS'...
	case $vns in
	    *-srcdir-*)
		srcdir=$_srcdir	;;
	    *)	srcdir=`
		    $0 expand makefile="$_makefile" -- '$(srcdir)'
		` || srcdir=.	;;
	esac
	rs_thead=`$0 quote SED="$SED" -- "$thead" re '|' rs`
	rs_tfoot=`$0 quote SED="$SED" -- "$tfoot" re '|' rs`
					## (RS,/)-quote (RE,|)-quoted template
					## head and foot.
	rs_shead=`$0 quote SED="$SED" -- "$shead" rs '|' rs`
	rs_sfoot=`$0 quote SED="$SED" -- "$sfoot" rs '|' rs`
					## (RS,/)-quote (RS,|)-quoted substi-
					## tution head and foot.
	gensubst_sed=`$SED 's/[^/][^/]*$/gensubst.sed/' <<EOF
$0
EOF`;	test -f "$gensubst_sed" || if test -f "$srcdir/$gensubst_sed"; then
	    gensubst_sed=$srcdir/$gensubst_sed
	else
	    echo "$0: $gensubst_sed: not found!" >&2; exit 1
	fi				## Try to auto-locate gensubst.sed...
	rs_gensubst_sed=`$0 quote SED="$SED" -- "$gensubst_sed" rs`
					## ...and (RS,/)-quote its pathname.
	$SED '
	    s/$/ /
	    s/\([^ ][^ ]*\) /s|'"$rs_thead"'\1'"$rs_tfoot"'|'"$rs_shead"'\1'"$rs_sfoot"'|g;/g
	    s/;$/'"$SQ $rs_shead"'FINISH_POST_SEDFLAGS'"$rs_sfoot"'/
	    s/^/'"$rs_shead"'FINISH_ANTE_SEDFLAGS'"$rs_sfoot"' -f '"$rs_gensubst_sed"' -e '"$SQ"'/
	' <<EOF
$*
EOF
					## Construct and emit result from quo-
	;;				## ted parts.
    substitute)				## 'substitute'...
	rs_thead=`$0 quote SED="$SED" -- "$thead" re '|' rs`
	rs_tfoot=`$0 quote SED="$SED" -- "$tfoot" re '|' rs`
					## (RS,/)-quote (RE,|)-quoted template
					## head and foot.
	rs_shead=`$0 quote SED="$SED" -- "$shead" rs '|' rs`
	rs_sfoot=`$0 quote SED="$SED" -- "$sfoot" rs '|' rs`
					## (RS,/)-quote (RS,|)-quoted substi-
					## tution head and foot.
	$SED '
	    s/$/ /
	    s/\([^ ][^ ]*\) /s|'"$rs_thead"'\1'"$rs_tfoot"'|'"$rs_shead"'\1'"$rs_sfoot"'|g;/g
	    s/;$/'"$SQ"'/;s/^/-e '"$SQ"'/
	' <<EOF
$*
EOF
					## Emit sed(1) "-e 's///'" option that
	;;				## substitutes extracted templates.
    expand)				## 'expand' [mode=MODE] STRING ...
	case ,$_mode, in
	    *,trace,*)			## MODE has 'trace' option?
		ax='td=40'	;;	## Yes, trace calls up to depth 40.
	    *)	ax='td=0'	;;	## No, don't trace calls.
	esac; case ,$_mode, in		## Which MODE?
	    *,raw,*)			## Raw...
		ax="$ax"'; vpd=0; vpm=0'
		;;			## Disable any processing.
	    *,get,*)			## Get...
		ax="$ax"'; vpd=2; vpm=4+8+16+32'
					## Disable expansion, enable line
		;;			## folding and space compression.
	    *,eval,*)			## Eval...
		ax="$ax"'; vpd=2; vpm=2+4+8+16+32+64'
					## Enable expansion, line folding,
		;;			## space compression, and quoting.
	    *)	ax="$ax"'; vpd=2; vpm=2+4+8+16+32'
					## Enable expansion, line folding,
		;;			## and space compression.
	esac; for us in ${1+"$@"}; do	## Convert STRINGs into awk(1) frag.
	    ax="$ax$NL		"'ui2us[++uc]='"$DQ$us$DQ"
	done
	nawk '
	    BEGIN {
		xd = uc = vc = 0
		'"$ax"'
		vkf = (((vpm/1)%2) >= 1); vxf = (((vpm/2)%2) >= 1)
	    }

	    function trace(fn,fa) {
		printf(sprintf("%%-%us%%s(\"%%s\")\n", xd), "#", fn, fa)
	    }

	    function strexp(us ,xs,vn) {
		if (++xd <= td) trace("strexp", us)
		xs = ""; while (   match(us, /\$\('"$re_ident"'\)/)	\
				|| match(us, /\${'"$re_ident"'}/)) {
		    xs = xs substr(us, 1, RSTART - 1)
		    vn = substr(us, RSTART + 2, RLENGTH - 3)
		    us = substr(us, RSTART + RLENGTH)
		    xs = xs varexp(vn)
		}
		--xd; return (xs us)
	    }

	    function varexp(vn ,vv) {
		if (++xd <= td) trace("varexp", vn)
		if (!vn2xc[vn] && (vn in ENVIRON)) {
		    vn2xc[vn] = 1; vn2vv[vn] = ENVIRON[vn]
		}
		if (!vn2xc[vn]) {
		    vv = vkf ? "${" vn "}" : ""
		} else if ((++vn2xc[vn] == 2) && vxf) {
		    vv = vn2vv[vn] = strexp(vn2vv[vn])
		} else {
		    vv = vn2vv[vn]
		}
		if (xd <= vpd) {
		    if (((vpm/ 4)%2) >= 1) gsub(/\\\n/, "\n", vv)
		    if (((vpm/ 8)%2) >= 1) gsub(/\n/, " ", vv)
		    if (((vpm/16)%2) >= 1) gsub(/[ \t]+/, " ", vv)
		    if (((vpm/32)%2) >= 1) {
			gsub(/(^[ \t]+|[ \t]+$)/, "", vv)
			gsub(/[ \t]*\n[ \t]*/, "\n", vv)
		    }
		    if (((vpm/64)%2) >= 1) {
			gsub(/'"$SQ"'/, "&\\\\&&", vv)
			sub(/^/, "'"$SQ"'", vv); sub(/$/, "'"$SQ"'", vv)
		    }
		}
		--xd; return (vv)
	    }

	    /^'"$re_ident"'[ \t]*:?=[ \t]*/ {
		match($0, /[ \t]*:?=[ \t]*/)
		vn = substr($0, 1, RSTART - 1)
		vv = substr($0, RSTART + RLENGTH)
		while ($0 ~ /\\$/) {
		    getline; vv = vv "\n" $0
		}; vn2xc[vn] = 1; vn2vv[vn] = vv
	    }

	    END {
		for (ui = 1; ui <= uc; ++ui)
		    printf("%s\n", strexp(ui2us[ui]))
	    }
	' "$_makefile" 2>/dev/null
	;;
    usage)
	echo "Usage: $0 SUBST [NAME=VALUE ...] UNFINISHED ..." >&2
	exit 2
	;;
esac
