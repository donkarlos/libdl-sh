dnl								-*-Autotest-*-
dnl libsafe.sh.at		- libsafe.sh tests
dnl
dnl Copyright Â© 2021 Das Computerlabor (DCl-M)
dnl
dnl This library is free software; you can redistribute it and/or
dnl modify it under the terms of the GNU Lesser General Public License
dnl as published by the Free Software Foundation; either
dnl version 2.1 of the License, or (at your option) any later version.
dnl
dnl This library is distributed in the hope that it will be useful,
dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
dnl Lesser General Public License for more details.
dnl
dnl You should have received a copy of the GNU Lesser General Public License
dnl along with this library; if not, write to the Free Software Founda-
dnl tion, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
dnl
dnl AUTHOR(S):	ks	Karl Schmitz <ks@computerlabor.org>
dnl
dnl WRITTEN BY:	ks	2021-05-13
dnl CHANGED BY:	ks	2021-05-20	dl_warn(): Suppress warnings for pre-
dnl					releases.
dnl					Add test group [libsafe.sh functions
dnl					are propely withdrawn?].
dnl		ks	2021-05-21	Add test group [libsafe.sh functions
dnl					are propely deprecated?].
dnl		ks	2021-05-23	Simplify embedded dl_warn(),
dnl					atlocal_function_deprecated(), and
dnl					atlocal_function_withdrawn().
dnl
dnl Test group 'Safe directory/file operations library libsafe.sh'
dnl
AT_BANNER([Safe directory/file operations library libsafe.sh])

dnl
dnl Check if 'dl_load safe' loads libsafe.sh
dnl
AT_SETUP(['dl_load safe' loads libsafe.sh?])
AT_KEYWORDS([libsafe.sh libsafe dl_load])
AT_CHECK([dnl
set -eu					## Employ strict execution environment
					## to ensure 'set -u' resilience.
test_atload_trace=:			## Initialize load-time hook's trace.
test_atload() {				## Declare load-time hook.
    test_atload_trace=:$1$test_atload_trace
}

test_atexit() {				## Declare exit-time hook.
    echo "test_atexit($status)"
    echo "$test_atload_trace"
}

case :$PATH: in				## Triggered by 'check-local:'?
    *:$abs_top_builddir/bin:*)		## Yes, export suitable LSP.
	LIBDL_SH_LIBRARY_PATH=$abs_top_builddir/lib
	LIBDL_SH_LIBEXECDIR=$abs_top_builddir/libexec
	export LIBDL_SH_LIBRARY_PATH LIBDL_SH_LIBEXECDIR
	;;
esac
eval "`libdl-sh load`"			## Load libdl.sh or die.
dl_atload test_atload && dl_atexit test_atexit
dl_load safe				## Register hooks and load
					## libsafe.sh.
], 0, [dnl				## And the winner is...
test_atexit(0)
:safe:undo:quote:dl:
], [dnl
])
AT_CLEANUP

dnl
dnl Check if safe_meta() inquiries
dnl   -	get package
dnl   -	get version
dnl   -	get api
dnl   -	get apis
dnl   -	get apis api
dnl   -	get apis full
dnl   -	get apis list
dnl   -	get apis r/o
dnl produce expected results.
dnl
dnl NOTE:   (1)	The first two of them can't be checked by the 'for' loop
dnl		because GNU Autotest implements any form of expected output
dnl		by means of safed here scripts, thus making parameter
dnl		substitutions impossible! |-(
dnl	    (2)	As a side effect, this check also ensures that libsafe.sh
dnl		supports only one API version which at the same time is
dnl		the default API version.
dnl	    (3)	The double brackets within the expected output provide "just
dnl		the right amount" of m4(1) quoting.
dnl
AT_SETUP(['safe_meta get' inquiries give expected results?])
AT_KEYWORDS([libsafe.sh libsafe safe_meta])
AT_CHECK([dnl
set -eu					## Employ strict execution environment
					## to ensure 'set -u' resilience.
case :$PATH: in				## Triggered by 'check-local:'?
    *:$abs_top_builddir/bin:*)		## Yes, export suitable LSP.
	LIBDL_SH_LIBRARY_PATH=$abs_top_builddir/lib
	LIBDL_SH_LIBEXECDIR=$abs_top_builddir/libexec
	export LIBDL_SH_LIBRARY_PATH LIBDL_SH_LIBEXECDIR
	;;
esac
eval "`libdl-sh load`"; dl_load safe	## Load libdl.sh and libsafe.sh or die.
case `safe_meta get package`_`safe_meta get version` in
    ${PACKAGE_TARNAME}_${PACKAGE_VERSION})
	:	;;			## See note (1).
    *)	test	;;
esac && for meta in							\
    'get api' 'get apis'						\
    'get apis api' 'get apis full' 'get apis list' 'get apis r/o'
do
    echo 'safe_meta '"$meta" && safe_meta $meta
					## Emit tag and inquiry result.
done
], 0, [dnl				## And the winner is...
safe_meta get api
0
safe_meta get apis
0
1
safe_meta get apis api
0
1
safe_meta get apis full
0;safe_meta(META [[ARG ...]]);2-4
0;safe_init(TAG);1
0;safe_mktmpdir(&DPN [[DRN]]);1-2
0;safe_mkdir(DPN ...);1-
0;safe_chdir(DPN);1
0;safe_touch(FPN ...);1-
0;safe_save(FPN);1
0;safe_rename(OLDPN NEWPN);2
0;safe_remove(PN ...);1-
0;safe_umask(UMASK COMMAND [[ARGUMENT ...]]);2-
0;safe_unlock(PN);1
0;safe_lock(PN);1
0;safe_wait(PN [[SECONDS=30]]);1-2
1;safe_meta(META [[ARG ...]]);2-4
1;safe_mktmpdir(&DPN [[DRN]]);1-2
1;safe_mkdir(DPN ...);1-
1;safe_chdir(DPN);1
1;safe_touch(FPN ...);1-
1;safe_save(FPN);1
1;safe_rename(OLDPN NEWPN);2
1;safe_remove(PN ...);1-
1;safe_umask(UMASK COMMAND [[ARGUMENT ...]]);2-
1;safe_unlock(PN);1
1;safe_lock(PN);1
1;safe_wait(PN [[SECONDS=30]]);1-2
safe_meta get apis list
0;safe_meta;2-4
0;safe_init;1
0;safe_mktmpdir;1-2
0;safe_mkdir;1-
0;safe_chdir;1
0;safe_touch;1-
0;safe_save;1
0;safe_rename;2
0;safe_remove;1-
0;safe_umask;2-
0;safe_unlock;1
0;safe_lock;1
0;safe_wait;1-2
1;safe_meta;2-4
1;safe_mktmpdir;1-2
1;safe_mkdir;1-
1;safe_chdir;1
1;safe_touch;1-
1;safe_save;1
1;safe_rename;2
1;safe_remove;1-
1;safe_umask;2-
1;safe_unlock;1
1;safe_lock;1
1;safe_wait;1-2
safe_meta get apis r/o
], [dnl
])
AT_CLEANUP

dnl
dnl Check if safe_meta() inquiries
dnl   -	get apis full
dnl   -	get apis list
dnl   -	get apis r/o
dnl hounour (i.e., apply) the extra sed(1) expression passed as 4th argument.
dnl
AT_SETUP(['safe_meta get apis' honours 4th argument?])
AT_KEYWORDS([libsafe.sh libsafe safe_meta])
AT_CHECK([dnl
set -eu					## Employ strict execution environment
					## to ensure 'set -u' resilience.
case :$PATH: in				## Triggered by 'check-local:'?
    *:$abs_top_builddir/bin:*)		## Yes, export suitable LSP.
	LIBDL_SH_LIBRARY_PATH=$abs_top_builddir/lib
	LIBDL_SH_LIBEXECDIR=$abs_top_builddir/libexec
	export LIBDL_SH_LIBRARY_PATH LIBDL_SH_LIBEXECDIR
	;;
esac
eval "`libdl-sh load`"; dl_load safe	## Load libdl.sh and libsafe.sh or die.
api=`safe_meta get api`			## Inquire default API version.
for meta in 'get apis full' 'get apis list' 'get apis r/o'; do
    case $meta in
	*full)	sx='/;safe_mkdir(/!d;s/;.*$//'	;;
	*list)	sx='/;safe_mkdir;/!d;s/;.*$//'	;;
	*r/o)	sx='/^'"$api"';/!d;s///'	;;
    esac
    echo 'safe_meta '"$meta" && safe_meta $meta "$sx"
					## Emit tag and inquiry result.
done
], 0, [dnl				## And the winner is...
safe_meta get apis full
0
1
safe_meta get apis list
0
1
safe_meta get apis r/o
], [dnl
])
AT_CLEANUP

dnl
dnl Check if the constants reported by safe_meta() inquiry get apis r/o (for
dnl the default API version) are actually defined after loading libsafe.sh.
dnl
AT_SETUP(['safe_meta get apis r/o' constants defined?])
AT_KEYWORDS([libsafe.sh libsafe safe_meta])
AT_CHECK([dnl
set -eu					## Employ strict execution environment
					## to ensure 'set -u' resilience.
case :$PATH: in				## Triggered by 'check-local:'?
    *:$abs_top_builddir/bin:*)		## Yes, export suitable LSP.
	LIBDL_SH_LIBRARY_PATH=$abs_top_builddir/lib
	LIBDL_SH_LIBEXECDIR=$abs_top_builddir/libexec
	export LIBDL_SH_LIBRARY_PATH LIBDL_SH_LIBEXECDIR
	;;
esac
eval "`libdl-sh load`"; dl_load safe	## Load libdl.sh and libsafe.sh or die.
status=0				## Assume success and inquire
api=`safe_meta get api`		## default API version.
for name in `safe_meta get apis r/o '/^'"$api"';/!d;s///'`; do
					## Foreach constant do...
    eval 'case ${'"$name"'+=} in
	=)  echo "$name";;
	*)  status=1	;;
    esac'				## Assume failure if it's unset. :-(
done; exit $status			## Indicate success or failure.
], 0, [dnl				## And the winner is...
], [dnl
])
AT_CLEANUP

dnl
dnl Check if the constants reported by safe_meta() inquiry get apis r/o (for
dnl the default API version) are actually readonly after loading libsafe.sh
dnl by trying to set them in a subshell environment.
dnl
AT_SETUP(['safe_meta get apis r/o' constants readonly?])
AT_KEYWORDS([libsafe.sh libsafe safe_meta])
AT_CHECK([dnl
set -eu					## Employ strict execution environment
					## to ensure 'set -u' resilience.
case :$PATH: in				## Triggered by 'check-local:'?
    *:$abs_top_builddir/bin:*)		## Yes, export suitable LSP.
	LIBDL_SH_LIBRARY_PATH=$abs_top_builddir/lib
	LIBDL_SH_LIBEXECDIR=$abs_top_builddir/libexec
	export LIBDL_SH_LIBRARY_PATH LIBDL_SH_LIBEXECDIR
	;;
esac
eval "`libdl-sh load`"; dl_load safe	## Load libdl.sh and libsafe.sh or die.
status=0				## Assume success and inquire
api=`safe_meta get api`			## default API version.
for name in `safe_meta get apis r/o '/^'"$api"';/!d;s///'`; do
					## Foreach constant do...
    (eval "$name=" 2>/dev/null) && status=1 || echo "$name"
					## Assume failure if we set it in a
					## subshell environment. 8-O
done; exit $status
], 0, [dnl				## And the winner is...
], [dnl
])
AT_CLEANUP

dnl
dnl Check if libsafe.sh functions are properly deprecated.
dnl
AT_SETUP([libsafe.sh functions are propely deprecated?])
AT_KEYWORDS([libsafe.sh libsafe deprecated])
AT_CHECK([dnl
set -eu					## Employ strict execution environment
					## to ensure 'set -u' resilience.
case :$PATH: in				## Triggered by 'check-local:'?
    *:$abs_top_builddir/bin:*)		## Yes, export suitable LSP.
	LIBDL_SH_LIBRARY_PATH=$abs_top_builddir/lib
	LIBDL_SH_LIBEXECDIR=$abs_top_builddir/libexec
	export LIBDL_SH_LIBRARY_PATH LIBDL_SH_LIBEXECDIR
	;;
esac
eval "`libdl-sh load`"; dl_load safe	## Load libdl.sh and libsafe.sh or die.
lib=safe; status=0			## Assume success.
atlocal_function_deprecated $lib 0 ${lib}_init :TAG || status=1
exit $status				## Indicate success or failure.
], 0, [dnl				## And the winner is...
safe_meta([[3]]set,api,0)=0
safe_init([[1]]:TAG)=126
], [dnl
])
AT_CLEANUP

dnl
dnl Check if libsafe.sh functions are properly withdrawn.
dnl
AT_SETUP([libsafe.sh functions are propely withdrawn?])
AT_KEYWORDS([libsafe.sh libsafe withdrawn])
AT_CHECK([dnl
set -eu					## Employ strict execution environment
					## to ensure 'set -u' resilience.
case :$PATH: in				## Triggered by 'check-local:'?
    *:$abs_top_builddir/bin:*)		## Yes, export suitable LSP.
	LIBDL_SH_LIBRARY_PATH=$abs_top_builddir/lib
	LIBDL_SH_LIBEXECDIR=$abs_top_builddir/libexec
	export LIBDL_SH_LIBRARY_PATH LIBDL_SH_LIBEXECDIR
	;;
esac
eval "`libdl-sh load`"; dl_load safe	## Load libdl.sh and libsafe.sh or die.
lib=safe; status=0			## Assume success.
atlocal_function_withdrawn $lib 1 ${lib}_init :TAG || status=1
exit $status				## Indicate success or failure.
], 0, [dnl				## And the winner is...
safe_meta([[3]]set,api,1)=0
safe_init([[1]]:TAG)=127
], [dnl
])
AT_CLEANUP

dnl
dnl Check if the functions reported by 'safe_meta get apis list' (for all
dnl API versions) indicate usage errors (i.e., return 2) when invoked with
dnl insufficient arguments.
dnl
dnl NOTE:   (1)	The test is driven by the 3rd field of the inquiry's output!
dnl
AT_SETUP([libsafe.sh functions indicate usage errors?])
AT_KEYWORDS([libsafe.sh libsafe usage])
AT_CHECK([dnl
set -eu					## Employ strict execution environment
					## to ensure 'set -u' resilience.
case :$PATH: in				## Triggered by 'check-local:'?
    *:$abs_top_builddir/bin:*)		## Yes, export suitable LSP.
	LIBDL_SH_LIBRARY_PATH=$abs_top_builddir/lib
	LIBDL_SH_LIBEXECDIR=$abs_top_builddir/libexec
	export LIBDL_SH_LIBRARY_PATH LIBDL_SH_LIBEXECDIR
	;;
esac
eval "`libdl-sh load`"; dl_load safe	## Load libdl.sh and libsafe.sh or die.
mp=safe_; status=0			## Assume success.
for api in `${mp}meta get apis`; do (	## Foreach API version do...
    trap '' 0				## Ignore EXIT traps within subshell.
    echo "${mp}meta set api $api"
    if ${mp}meta set api $api; then
	ifs=$IFS; IFS=$NL; set shiftee `${mp}meta get apis list 's/^'"$api"';//;t0
		d;:0
		s/^\('"$dl_re_id"'\);\('"$dl_re_0n"'\)-\('"$dl_re_1n"'\)$/name=\1 min=\2 max=\3/;tp
		s/^\('"$dl_re_id"'\);\('"$dl_re_0n"'\)-$/name=\1 min=\2 max=/;tp
		s/^\('"$dl_re_id"'\);\('"$dl_re_0n"'\)$/name=\1 min=\2 max=\2/;tp
		s/^.*$/test/;:p
	'`; shift; IFS=$ifs
	for signature in ${1+"$@"}; do	## Foreach parsed signature (see note
					## (1)) do...
	    eval "$signature" && case $name in
					## Function exempted?
		_)			## Yes.
		    ;;
		*)			## No, make passes at function.
		    args= n=0; while test "$n" -lt "$min"; do
			echo "$name$args"
			$name $args && exit 1 || case $? in
			    2)		;;
			    *)  exit 1	;;
			esac
			n=`expr $n + 1`; args="$args $n"
		    done
		    ;;
	    esac
	done
    fi
) || status=1; done; exit $status
], 0, [dnl				## And the winner is...
safe_meta set api 0
safe_meta
safe_meta 1
safe_init
safe_mktmpdir
safe_mkdir
safe_chdir
safe_touch
safe_save
safe_rename
safe_rename 1
safe_remove
safe_umask
safe_umask 1
safe_unlock
safe_lock
safe_wait
safe_meta set api 1
safe_meta
safe_meta 1
safe_mktmpdir
safe_mkdir
safe_chdir
safe_touch
safe_save
safe_rename
safe_rename 1
safe_remove
safe_umask
safe_umask 1
safe_unlock
safe_lock
safe_wait
], [dnl
])
AT_CLEANUP
