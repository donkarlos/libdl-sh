#! /bin/sh ##
#-----------------------------------------------------------------------------
#   atlocal			- Test suite's local definitions
#
#   Copyright Â© 2021 Das Computerlabor (DCl-M)
#
#   This library is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public License
#   as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public License
#   along with this library; if not, write to the Free Software Founda-
#   tion, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
##
##  AUTHOR(S):	ks	Karl Schmitz <ks@computerlabor.org>
##
##  WRITTEN BY:	ks	2021-04-28
##  CHANGED BY:	ks	2021-05-03	Define PACKAGE_TARNAME, PACKAGE_-
##					VERSION, and installation directories.
##		ks	2021-05-18	Declare global variables readonly.
##					Add atlocal_get_specials()
##					and atlocal_set_specials().
##		ks	2021-05-20	Add atlocal_function_withdrawn().
##		ks	2021-05-21	Add atlocal_function_deprecated(),
##					atlocal_trace(), atlocal_trace_with_-
##					output(), and atlocal_returns().
##		ks	2021-05-23	Add atlocal_trace_variable(),
##					atlocal_trace_invocation(), and
##					atlocal_trace_invocation_returns().
##----------------------------------------------------------------------------
##  Global variables:
#-----------------------------------------------------------------------------
PACKAGE_TARNAME=@PACKAGE_TARNAME@
PACKAGE_VERSION=@PACKAGE_VERSION@
bindir=@bindir@
libdir=@shlibdir@
pkgdatadir=@pkgdatadir@
sysconfdir=@sysconfdir@
readonly PACKAGE_TARNAME PACKAGE_VERSION bindir libdir pkgdatadir sysconfdir

##----------------------------------------------------------------------------
##  atlocal_trace(FUNC [ARG ...])
##				Trace FUNCtion's invocation to stdout, re-
##				writing certain "dangerous" characters
##
##  Non-local variables:
##	- NL		(R) A newline.		(ASCII <LF>)
##	- CR		(R) A carriage return.	(ASCII <CR>)
##	- BS		(R) A backslash.	(\\)
##----------------------------------------------------------------------------
atlocal_trace() {
    case ${1+=} in			## Usage OK?
	=)  local func="$1"; shift	## Yes, fetch FUNC.
	    local ifs args; ifs=$IFS; IFS=,; args=$*; IFS=$ifs
	    ;;
	*)  return 2			## No, indicate abuse!
	    ;;
    esac; sed '
	:N'"$NL"'$!{;N;bN'"$NL"'}
	s/'"$BS$NL"'/<NL>/g;s/'"$CR"'/<CR>/g;s/	/<HT>/g;s/ /<SP>/g
    ' <<EOF
$func([$#]$args)
EOF
}

##----------------------------------------------------------------------------
##  atlocal_trace_with_output(STDOUT FUNC [ARG ...])
##				Trace FUNCtion's invocation together with that
##				invocation's output to stdout, rewriting cer-
##				tain "dangerous" characters
##
##  Non-local variables:
##	- NL		(R) A newline.		(ASCII <LF>)
##	- CR		(R) A carriage return.	(ASCII <CR>)
##	- BS		(R) A backslash.	(\\)
##----------------------------------------------------------------------------
atlocal_trace_with_output() {
    case ${2+=} in			## Usage OK?
	=)  local output="$1" func="$2"; shift 2
	    local ifs args; ifs=$IFS; IFS=,; args=$*; IFS=$ifs
	    ;;
	*)  return 2			## No, indicate abuse!
	    ;;
    esac; sed '
	:N'"$NL"'$!{;N;bN'"$NL"'}
	s/'"$BS$NL"'/<NL>/g;s/'"$CR"'/<CR>/g;s/	/<HT>/g;s/ /<SP>/g
    ' <<EOF
$func([$#]$args)=>$output
EOF
}

##----------------------------------------------------------------------------
##  atlocal_returns(STATUS FUNC [ARG ...])
##				Check if FUNC's invocation returns STATUS
##----------------------------------------------------------------------------
atlocal_returns() {
    case ${2+=} in			## Usage OK?
	=)  local expected="$1" returned; shift
	    atlocal_trace "$@"		## Yes, fetch expected exit status
	    ;;				## and trace function invocation.
	*)  return 2			## No, indicate abuse!
	    ;;
    esac; (				## Invoke function within relaxed
	trap '' 0; set +e; "$@"		## environment.
    ); returned=$?; test $returned -eq "$expected" || {
	echo "returned $returned; expected $expected"
	return 1
    }
}

##----------------------------------------------------------------------------
##  atlocal_trace_variable(NAME)
##				Trace assignment to NAME if it's set or just
##				'unset NAME' otherwise
##
##  Non-local variables:
##	- NL		(R) A newline.		(ASCII <LF>)
##	- CR		(R) A carriage return.	(ASCII <CR>)
##	- BS		(R) A backslash.	(\\)
##----------------------------------------------------------------------------
atlocal_trace_variable() {
    expr "${1+_$1}" : "_$dl_re_id" >/dev/null || return 2
    local sx='
	:N'"$NL"'$!{;N;bN'"$NL"'}
	s/'"$BS$NL"'/<NL>/g;s/'"$CR"'/<CR>/g;s/	/<HT>/g;s/ /<SP>/g
    '; eval 'case ${'"$1"'+=} in
	=)  sed "$sx" <<EOF
'"$1"'=`quote_sh "$'"$1"'"`
EOF
	    ;;
	*)	echo unset '"$1"'
	    ;;
    esac'
}

##----------------------------------------------------------------------------
##  atlocal_trace_invocation(FUNC [ARG ...])
##				Invoke FUNC, capture returned status and trace
##				invocation with status
##
##  NOTE:   (1)	Temporarily disables sh(1) option errexit to avoid triggering
##		EXIT trap if FUNC's invocation fails!
##
##  Non-local variables:
##	- NL		(R) A newline.		(ASCII <LF>)
##	- CR		(R) A carriage return.	(ASCII <CR>)
##	- BS		(R) A backslash.	(\\)
##----------------------------------------------------------------------------
atlocal_trace_invocation() {
    expr "${1+_$1}" : "_$dl_re_id" >/dev/null || return 2
					## Indicate abuse if necesssary.
    local func="$1" flags ifs args returned; shift; case $- in
	*e*)	flags=${flags-}e;;
    esac; ifs=$IFS; IFS=,; args=$*; IFS=$ifs
    ${flags+set +$flags}
    $func ${1+"$@"}; returned=$?
    ${flags+set -$flags}
    sed '
	:N'"$NL"'$!{;N;bN'"$NL"'}
	s/'"$BS$NL"'/<NL>/g;s/'"$CR"'/<CR>/g;s/	/<HT>/g;s/ /<SP>/g
    ' <<EOF
$func([$#]$args)=$returned
EOF
    return $returned
}

##----------------------------------------------------------------------------
##  atlocal_trace_invocation_returns(STATUS FUNC [ARG ...])
##				Invoke FUNC, capture returned status, trace
##				invocation with status, and check if FUNC's
##				invocation returned STATUS
##----------------------------------------------------------------------------
atlocal_trace_invocation_returns() {
    expr "${2+_$2}" : "_$dl_re_id" >/dev/null || return 2
					## Indicate abuse if necesssary.
    local expected="$1" returned; shift
    atlocal_trace_invocation "$@" && returned=$? || returned=$?
    test $returned -eq "$expected" 2>/dev/null || return 1
}

##----------------------------------------------------------------------------
##  atlocal_get_special_cs()	Emit joint set of quote operator's special
##				characters
##
##  Non-local variables:
##	- NL		(R) A newline.		(ASCII <LF>)
##	- BS		(R) A backslash.	(\\)
##	- DS		(R) A dollar sign.	(\$)
##	- quote_cs_sh	(R) Special sh(1) character set sans '~'.
##	- quote_cs_bre	(R) Special BRE character set sans '^' and '$'.
##	- quote_cs_ere	(R) Special ERE character set with '^' and '$'.
##	- quote_cs_brs	(R) Special 's///' right-hand side character set
##----------------------------------------------------------------------------
atlocal_get_special_cs() {
    sed '
	:N'"$NL"'$!{;N;bN'"$NL"'}
	s/^/%/;:0'"$NL"'s/%\(.\)/\1'"$BS$NL"'%/;t0
	s/%$//
    ' <<EOF | LC_COLLATE=C sort -u | sed '
	:N'"$NL"'$!{;N;s/'"$BS$NL"'//2;tN'"$NL"'bN'"$NL"'}
    '
$quote_cs_sh~$quote_cs_bre^$DS$quote_cs_ere$quote_cs_brs
EOF
}

##----------------------------------------------------------------------------
##  atlocal_set_special_cs(CS)	Split character set CS into quoted word list
##				usable with 'eval set shiftee ...; shift'
##
##  Non-local variables:
##	- NL		(R) The newline   character.
##	- BS		(R) The backspace character.
##	- SQ		(R) Single quote.
##	- LB		(R) Left  (opening) bracket (i.e., '[').
##	- RB		(R) Right (closing) bracket (i.e., ']').
##	- quote_cs_sh	(R) Special sh(1) character set sans '~'.
##----------------------------------------------------------------------------
atlocal_set_special_cs() {
    sed '
	:N'"$NL"'$!{;N;bN'"$NL"'}
	s/^'"$BS$NL"'/'"$SQ"'&'"$SQ"' %/;t0
	:0'"$NL"'s/%\('"$LB$quote_cs_sh~$RB"'\)/'"$BS$BS"'\1 %/;t0
	s/%\(.\)/\1 %/;t0
	s/ %//
    ' <<EOF
$1
EOF
}

##----------------------------------------------------------------------------
##  atlocal_function_deprecated(LIB API FUNC [ARG ...])
##				Check if LIBrary release deprecated FUNC
##----------------------------------------------------------------------------
atlocal_function_deprecated() {
    case ${3+=$3/`dl_meta get loaded`} in
					## Usage OK?/LIB is prefix of FUNC?/
					## LIB is demand-loaded?
	=${1-}/*:${1-}:*|=${1-}_*/*:${1-}:*)
					## Y/Y/Y: Declare local variables.
	    local meta="${1}_meta" version
	    version=`$meta get version` || return 1
	    ;;
	*)  return 2			## N/?/?: Indicate abuse!
	    ;;
    esac; (				## Within subshell environment do...
	dl_warn() {			## Overload dl_warn() with simplified
	    echo dl_warn ${1+"$@"}	## version...
	    case ${6+6}${5+5}${4+4}${3+3}${1+=$1} in
		43=rel-req-set-api)
		    return 3    ;;
		543=rel-dpr-func)
		    verscmp --target=fast -- "$version" lt-nl "$3" && echo lt-nl
		    return 126  ;;	## Suppress FUNC's execution!
		43=api-wdr-func)
		    return 127  ;;
		43=rel-wdr-meta)
		    return 2    ;;
		*)  return 3    ;;
	    esac
	}
	trap '' 0			## Ignore EXIT traps.
	echo "$meta set api $2"		## Select library's API version.
	$meta set api "$2"
	echo "$meta get api list"
	$meta get apis list | grep -e "^$2;$3;" >/dev/null 2>&1 || {
					## Function listed for library's API
					## version?
	    exit 1			## No, indicate failure!
	}
	shift 2; echo "$*"		## Log function invocation and disable
	set +e				## shell's errexit feature.
	"$@"; echo $?			## Invoke function to see if it trig-
					## gers dl_warn() and log exit status.
    ) || return $?			## Indicate success or failure.
}

##----------------------------------------------------------------------------
##  atlocal_function_withdrawn(LIB API FUNC [ARG ...])
##				Check if LIBrary withdrew FUNC in API version
##----------------------------------------------------------------------------
atlocal_function_withdrawn() {
    case ${3+=$3/`dl_meta get loaded`} in
					## Usage OK?/LIB is prefix of FUNC?/
					## LIB is demand-loaded?
	=${1-}/*:${1-}:*|=${1-}_*/*:${1-}:*)
	    local meta="${1}_meta"	## Y/Y/Y: Declare local variable.
	    ;;
	*)  return 2			## N/?/?: Indicate abuse!
	    ;;
    esac; (				## Within subshell environment do...
	dl_warn() {			## Overload dl_warn() with simplified
	    echo dl_warn ${1+"$@"}	## version...
	    case ${6+6}${5+5}${4+4}${3+3}${1+=$1} in
		43=rel-req-set-api)
		    return 3    ;;
		543=rel-dpr-func)
		    return 0    ;;
		43=api-wdr-func)
		    return 127  ;;
		43=rel-wdr-meta)
		    return 2    ;;
		*)  return 3    ;;
	    esac
	}
	trap '' 0			## Ignore EXIT traps.
	echo "$meta set api $2"		## Select library's API version.
	$meta set api "$2"
	echo "$meta get api list"
	$meta get apis list | grep -e "^$2;$3;" >/dev/null 2>&1 && {
					## Function still listed for library's
					## API version?
	    exit 1			## Yes, indicate failure!
	}
	shift 2; echo "$*"		## Log function invocation and disable
	set +e				## shell's errexit feature.
	"$@"; echo $?			## Invoke function to see if it trig-
					## gers dl_warn() and log exit status.
    ) || return $?			## Indicate success or failure.
}
