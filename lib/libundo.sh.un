#! /bin/sh ##
#-----------------------------------------------------------------------------
#   libundo.sh			- Undo stack management library
#
#   Copyright (C) 2013 Karl Schmitz
#
#   This library is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public License
#   as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public License
#   along with this library; if not, write to the Free Software Founda-
#   tion, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
##
##  AUTHOR(S):	ks	Karl Schmitz <carolus.faber@gmail.com>
##
##  WRITTEN BY:	ks	2013-02-13
##  CHANGED BY:
##----------------------------------------------------------------------------
##  Global variables:
#-----------------------------------------------------------------------------
undo_stack=
undo_exit0=

##----------------------------------------------------------------------------
##  undo_init(TAG)		Set cleanups tag for successful exit
##----------------------------------------------------------------------------
undo_init () {
    case $1 in				## Cleanups tag is first?
	::*)	return 2	;;	## No, it's a mark!
	:?*)	undo_exit0=$1	;;	## Yes, set cleanups tag.
	*)	return 2	;;	## No, it's not a tag!
    esac
}

##----------------------------------------------------------------------------
##  undo_emit(MODE MARK)	Emit undos within MARKed range and MARK,
##  undo_emit(MODE MARK TAG)	Emit TAGged undos within MARKed range,
##  undo_emit(MODE TAG)		Emit TAGged undos, or
##  undo_emit(MODE [COUNT=1])	Emit COUNT undos on behalf of undo_MODE(),
##				where MODE is drop or keep.
##
##  NOTE:   (1)	When emitting a marked range, an empty line is prepended
##		so that the range matches even if MARK is on top.
##		Otherwise, the undo stack might be accidentally cleared or
##		not modified at all!
##----------------------------------------------------------------------------
undo_emit () {
    local i mark range km d1 sedex

    case $1 in				## Which mode?
	drop)		;;		## Drop, i.e. don't invert deletes.
	keep) i='!'	;;		## Keep, i.e. invert deletes.
	*)    return 2	;;		## None of the above!
    esac

    case $2 in				## Mark is next?
	::?*)				## Yes, derive mark/range fragments.
	    mark='/^#{'"$2"'::}#$/'; range="1,$mark"
	    case $1 in			## Which mode?
		keep) km="${mark}bp;" d1=';1d;:p';;
					## Keep, i.e. keep mark but drop 1st.
	    esac
	    case $3 in			## Tag is next?
		::*)	return 2		;;
					## No, it's another mark!
		:?*)	sedex="{;$km/#$3"'$/'"${i}d;}$d1";;
					## Yes, (don't) drop tagged undos
					## within marked range.
		?*)	return 2		;;
					## No, it's not a tag!
		*)	sedex="${i}d$d1"	;;
	    esac			## No, (don't) drop marked range.
	    ;;
	::*)				## Tag is first?
	    return 2			## It's a mark!
	    ;;
	:?*)
	    sedex="/#$2"'$/'"${i}d"	## Yes, (don't) drop tagged undos.
	    ;;
	*)  sedex="1${2+,$2}${i}d"	## No, assume it's a count.
	    ;;
    esac
    sed "$range$sedex" 2>/dev/null <<EOF
${range+$NL}$undo_stack
EOF
}

##----------------------------------------------------------------------------
##  undo_mark(MARK)		Push MARK onto undo stack
##
##  NOTE:   (1)	Contrary to tags (which are appended as a comment), marks
##		occupy a whole line. Keep this in mind when pulling/dropping
##		undos by count!
##----------------------------------------------------------------------------
undo_mark () {
    case $1 in				## Mark is first?
	::?*)	undo_stack="#{$1::}#$NL$undo_stack"	;;
					## Push mark onto undo stack.
	*)	return 2				;;
    esac				## No, it's not a mark!
}

##----------------------------------------------------------------------------
##  undo_push([TAG] COMMAND [ARGUMENT|REDIRECTION ...])
##				Push (TAGged) COMMAND (with quoted ARGUMENTs
##				and/or raw REDIRECTIONs) onto undo stack
##----------------------------------------------------------------------------
undo_push () {
    local tag

    case $1 in				## Tag is first?
	::*) return 2		;;	## No, it's a mark!
	:?*) tag=" #$1"; shift	;;	## Yes, fetch it.
    esac
    undo_stack="`quote_command ${1+"$@"}`$tag$NL$undo_stack"
}					## Push (tagged) undo onto stack.

##----------------------------------------------------------------------------
##  undo_pull(TAG|[COUNT=1])	Apply and drop (tagged) command(s)
##----------------------------------------------------------------------------
undo_pull () {
    local script

    case $1 in
	:*) script='/#'"$1"'$/p';;
	*)  script="1${1+,$1}p"	;;
    esac
    eval "`echo "$undo_stack" | sed -n "$script"`"
    undo_drop ${1+"$1"}
}

##----------------------------------------------------------------------------
##  undo_drop(TAG|[COUNT=1])	Drop (tagged) command(s) from undo stack
##----------------------------------------------------------------------------
undo_drop () {
    local script

    case $1 in
	:*) script='/#'"$1"'$/d';;
	*)  script="1${1+,$1}d"	;;
    esac
    undo_stack=`echo "$undo_stack" | sed "$script"`
}

##----------------------------------------------------------------------------
##  undo_exit(STATUS)		Apply cleanups/undos
##
##  NOTE:   (1)	This function is registered for invocation by dl_exit()!
##----------------------------------------------------------------------------
undo_exit () {
    case ${1-1}$undo_exit0 in		# Exit with...
	0)				# ...success and cleanups tag unset?
	    ;;				# What's done is done.
	0:*)				# ...success and cleanups tag set?
	    eval "`echo "$undo_stack" | grep '#'"$undo_exit0"'$'`"
	    ;;				# Pick and apply cleanups.
	*)				# ...failure?
	    eval "$undo_stack"		# Apply undos.
	    ;;
    esac
}

##----------------------------------------------------------------------------
##  Initialization:
##----------------------------------------------------------------------------
dl_load quote && dl_atexit undo_exit
