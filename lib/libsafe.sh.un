#! /bin/sh ##
#-----------------------------------------------------------------------------
#   libsafe.sh			- Safe directory/file operations library
#
#   Copyright Â© 2013-2021 Das Computerlabor (DCl-M)
#
#   This library is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public License
#   as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public License
#   along with this library; if not, write to the Free Software Founda-
#   tion, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
##
##  AUTHOR(S):	ks	Karl Schmitz <ks@computerlabor.org>
##
##  WRITTEN BY:	ks	2013-02-14
##  CHANGED BY:	ks	2016-05-19	Use meta prefix.
##		ks	2016-05-24	Add 'meta get package/version'.
##					Use 'meta get apis' separator ';'.
##		ks	2017-01-15	Update copyright.
##					Add 'meta session *'.
##					Add 'meta get/set 0tag' as substitute
##					for safe_init().
##		ks	2020-05-12	Limit valid 'meta session' operations.
##					Make 'meta get apis FORMAT' properly
##					handle namespace rule-exempted names.
##		ks	2021-05-01	'set -u'-harden safe_meta().
##		ks	2021-05-08	Make 'safe_meta get apis' SEDEX
##					labels portable.
##		ks	2021-05-15	Prepare for multiple API versions.
##					Deprecate/Withdraw safe_init().
##					'set -u'-harden safe_init(), safe_-
##					mktmpdir(), safe_mkdir(), safe_-
##					chdir(), safe_touch(), safe_save(),
##					and safe_rename().
##					Prepare API version 1.
##					safe_meta(): Cleanups tag may be set
##					once only.
##----------------------------------------------------------------------------
##  Global variables:
#-----------------------------------------------------------------------------
safe_package=@PACKAGE_TARNAME@		## Define source package name
safe_version=@PACKAGE_VERSION@		## and version.
safe_api=0				## Preset default API version.
safe_ro=,				## No internal variables frozen yet.
safe_suffix=$$
safe_tarid=0
safe_locks=
readonly safe_package safe_version; unset safe_0tag safe_tmpdir
					## Discard spurious environment.

##----------------------------------------------------------------------------
##  safe_meta(META [ARG ...])	Perform META operation (with ARGs)
##----------------------------------------------------------------------------
safe_meta() {
    local mp=safe_			## Set meta prefix.

    case ${2+=}${1+$1-}${2-} in		## Which META operation?
	=get-apis)			## Inquire APIs...
	    local sx ms=\;
	    local fa='/^a'"$ms"'/!d;s///' da='s/([^)'"$ms"'(]*)//'	\
		  ff='/^F'"$ms"'/{;s///;t2'"$NL"'};/^f'"$ms"'/!d;s///'	\
		  fr='/^R'"$ms"'/{;s///;t2'"$NL"'};/^r'"$ms"'/!d;s///'	\
		  p2=';s/'"$ms"'/&'"$mp"'/;:2'
	    case ${3-api} in		## Which format?
		api)	sx="$fa"			;;
		full)	sx="$ff$p2${4+$NL$4}"		;;
		list)	sx="$ff$p2$NL$da${4+;$4}"	;;
		r/o)	sx="$fr$p2${4+$NL$4}"		;;
		*)	return 1			;;
	    esac
	    sed "$sx" <<EOF
a${ms}0
f${ms}0${ms}meta(META [ARG ...])${ms}2-4
f${ms}0${ms}init(TAG)${ms}1
f${ms}0${ms}mktmpdir(&DPN [DRN])${ms}1-2
f${ms}0${ms}mkdir(DPN ...)${ms}1-
f${ms}0${ms}chdir(DPN)${ms}1
f${ms}0${ms}touch(FPN ...)${ms}1-
f${ms}0${ms}save(FPN)${ms}1
f${ms}0${ms}rename(OLDPN NEWPN)${ms}2
f${ms}0${ms}remove(PN ...)${ms}1-
f${ms}0${ms}umask(UMASK COMMAND [ARGUMENT ...])${ms}2-
f${ms}0${ms}unlock(PN)${ms}1
f${ms}0${ms}lock(PN)${ms}1
f${ms}0${ms}wait(PN [SECONDS=30])${ms}1-2
f${ms}1${ms}meta(META [ARG ...])${ms}2-4
f${ms}1${ms}mktmpdir(&DPN [DRN])${ms}1-2
f${ms}1${ms}mkdir(DPN ...)${ms}1-
f${ms}1${ms}chdir(DPN)${ms}1
f${ms}1${ms}touch(FPN ...)${ms}1-
f${ms}1${ms}save(FPN)${ms}1
f${ms}1${ms}rename(OLDPN NEWPN)${ms}2
f${ms}1${ms}remove(PN ...)${ms}1-
f${ms}1${ms}umask(UMASK COMMAND [ARGUMENT ...])${ms}2-
f${ms}1${ms}unlock(PN)${ms}1
f${ms}1${ms}lock(PN)${ms}1
f${ms}1${ms}wait(PN [SECONDS=30])${ms}1-2
EOF
	    ;;
	=get-package|=get-version|=get-api|=get-0tag)
					## Inquire internal variable...
	    eval 'case ${'"$mp$2"'+=} in
		=)  echo "$'"$mp$2"'"	;;
		*)  return 1		;;
	    esac'
	    ;;
	=set-*)				## Set internal variable once...
	    case ${4+4}${3+=}$2 in	## Usage OK?
		=api)	${mp}meta get apis | fgrep -qxe "$3"
			;;		## Yes, try to validate API version.
		=0tag)	undo_meta ${1+"$@"}
			;;		## Yes, try to validate tag.
		*)	return 2	## No, indicate abuse!
			;;
	    esac && eval 'case ${'"$mp$2"'+=$'"$mp$2"'}$'"$mp"'ro in
		=$3,*)	return 0	## Variable still settable?
			;;		## Maybe, but idempotence is OK.
		=*,$2,*)return 1	## No, indicate failure!
			;;
		*)  	'"$mp$2"'=$3 '"$mp"'ro=$'"$mp"'ro$2,; readonly '"$mp$2"'
			;;		## Yes, set and freeze it.
	    esac'
	    ;;
	=session-init|=session-load|=session-dump|=session-exit)
	    :				## Session init/load/dump/exit...
	    ;;				## ...is a no-op.
	*)  return 2			## Anything else...
	    ;;				## ...is abuse!
    esac
}

##----------------------------------------------------------------------------
##  safe_init(TAG)		Set cleanups tag for successful exit
##----------------------------------------------------------------------------
safe_init() {
    case ${safe_api--} in
	1)  dl_warn api-wdr-func "safe;_init([$#]$*)" 1 0		;;
	*)  dl_warn rel-dpr-func "safe;_init([$#]$*)" 0.4 0.5 0.3.6	;;
    esac && safe_meta set 0tag ${1+"$1"}
}

##----------------------------------------------------------------------------
##  safe_mktmpdir(&DPN [DRN])	Safely make temporary directory
##----------------------------------------------------------------------------
safe_mktmpdir() {
    case ${3+3}${2+=}${1+=}$safe_ro in	## Usage OK?/Temp. directory made?
	=*,tmpdir,*)			## Y/Y.
	    ;;
	=*)				## Y/N: Try to make it once and for all.
	    safe_tmpdir=`mktemp -d` &&
		undo_push $safe_0tag 'rm -rf' "$safe_tmpdir" ||
		return 1
	    readonly safe_tmpdir; safe_ro=${safe_ro}tmpdir,
	    ;;
	*)  return 2			## No, indicate abuse!
	    ;;
    esac && case $# in			## DRN passed?
	2)  mkdir -p "$safe_tmpdir/$2" && eval "$1"'=$safe_tmpdir/$2'
	    ;;				## Yes, try to make it and pass it on.
	1)  eval "$1"'=$safe_tmpdir'	## No, just pass it on.
	    ;;
    esac
}

##----------------------------------------------------------------------------
##  safe_mkdir(DPN ...)		Safely make directories
##----------------------------------------------------------------------------
safe_mkdir() {
    case ${1+=} in			## Usage OK?
	=)  local dpn; for dpn in "$@"; do
					## Yes, foreach directory do...
		test -d "$dpn" || {	## Does it already exist?
		    safe_mkdir "`dirname "$dpn"`" && mkdir "$dpn" &&
			undo_push rmdir "$dpn" || break
		}			## No, try to make it recursively,
	    done			## pushing undos along the way...
	    ;;
	*)  return 2			## No, indicate abuse!
	    ;;
    esac
}

##----------------------------------------------------------------------------
##  safe_chdir(DPN)		Safely change directory
##----------------------------------------------------------------------------
safe_chdir() {
    case ${2+2}${1+=} in		## Usage OK?
	=)  local cwd="`pwd`"; cd "$1" &&
		undo_push ${safe_0tag+"$safe_0tag"} cd "$cwd"
	    ;;
	*)  return 2			## No, indicate abuse!
	    ;;
    esac
}

##----------------------------------------------------------------------------
##  safe_touch(FPN ...)		Safely touch file(s) into existence
##----------------------------------------------------------------------------
safe_touch() {
    case ${1+=} in			## Usage OK?
	=)  local fpn; for fpn in "$@"; do
					## Yes, foreach file do...
		test -f "$fpn" || {	## Does it already exist?
		    safe_mkdir "`dirname "$fpn"`" && touch "$fpn" &&
			undo_push 'rm -f' "$fpn" || break
		}			## No, try to make it recursively,
	    done			## pushing undos along the way...
	    ;;
	*)  return 2			## No, indicate abuse!
	    ;;
    esac
}

##----------------------------------------------------------------------------
##  safe_save(FPN)		Safely save existing file
##----------------------------------------------------------------------------
safe_save() {
    case ${2+2}${1+=} in		## Usage OK?
	=)  local fpn="$1" bpn="$1~B$safe_suffix"
	    test -f "$fpn" && {		## Yes, and file exists?
		test -f "$bpn" || {	## Yes, and file had been saved?
		    cp -p "$fpn" "$bpn" &&
			undo_push ${safe_0tag+"$safe_0tag"} 'rm -f' "$bpn" &&
			undo_push mv "$bpn" "$fpn"
		}			## No, try to save it.
	    }
	    ;;
	*)  return 2			## No, indicate abuse!
	    ;;
    esac
}

##----------------------------------------------------------------------------
##  safe_rename(OLDPN NEWPN)	Safely rename file
##----------------------------------------------------------------------------
safe_rename() {
    case ${3+3}${2+=} in		## Usage OK?
	=)  test -e "$1" && {
		test -e "$2" || {
		    mv "$1" "$2" && undo_push mv "$2" "$1"
		}
	    }
	    ;;
	*)  return 2			## No, indicate abuse!
	    ;;
    esac
}

##----------------------------------------------------------------------------
##  safe_remove(PN ...)		Safely remove directory tree(s)/file(s)
##----------------------------------------------------------------------------
safe_remove() {
    local tmpdn tarpn pn

    safe_mktmpdir tmpdn safe && {	## Make temporary directory.
	safe_tarid=`expr $safe_tarid + 1`
	tarpn=$tmpdn/$safe_tarid.tar	## Construct backup archive's name.
	for pn in ${1+"$@"}; do		## Foreach removee do...
	    test -e "$pn" && {		## Append it to backup archive.
		tar rPf "$tarpn" "$pn" || return 1
	    }
	done
	if test -e "$tarpn"; then
	    undo_push 'tar xPf' "$tarpn" '2>/dev/null' && rm -rf "$@"
	else
	    :
	fi
    }
}

##----------------------------------------------------------------------------
##  safe_umask(UMASK COMMAND [ARGUMENT ...])
##				Invoke COMMAND with umask UMASK
##----------------------------------------------------------------------------
safe_umask() {
    local umask=`umask` status		## Save umask.

    umask $1; shift			## Adjust umask.
    ${1+"$@"}				## Invoke command.
    status=$?; umask $umask		## Save status and restore umask.

    return $status			## Indicate status.
}

##----------------------------------------------------------------------------
##  safe_unlock(PN)		Safely unlock directory or file PN
##----------------------------------------------------------------------------
safe_unlock() {
    echo "$safe_locks" | fgrep -qxe "$1" && rmdir "$1~lock" && {
	safe_locks="`echo "$safe_locks" | fgrep -vxe "$1"`" || :
    }
}

##----------------------------------------------------------------------------
##  safe_lock(PN)		Safely try locking directory or file PN
##----------------------------------------------------------------------------
safe_lock() {
    echo "$safe_locks" | fgrep -qxe "$1" || {
	safe_mkdir "`dirname "$1"`" &&
	    safe_umask 277 mkdir "$1~lock" 2>/dev/null &&
	    undo_push $safe_0tag safe_unlock "$1" &&
	    safe_locks="$safe_locks$1$NL"
    }
}

##----------------------------------------------------------------------------
##  safe_wait(PN [SECONDS=30])	Try locking PN within SECONDS seconds
##----------------------------------------------------------------------------
safe_wait() {
    local seconds="${2-30}"

    until safe_lock "$1"; do		## Until we lock map file do...
	test -d "$1~lock" || return 1	## Cond. indic. failure to lock at all.
	sleep 1; seconds=`expr $seconds - 1`
	test $seconds -gt 0 || return 2	## Cond. indicate timeout.
    done
}

##----------------------------------------------------------------------------
##  Initialization:
##----------------------------------------------------------------------------
dl_load undo
