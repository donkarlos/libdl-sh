#! /usr/bin/awk -f ##
#-----------------------------------------------------------------------------
#   conf.awk			- libconf.sh GIT-style config. file processor
#
#   Copyright (C) 2013, Karl Schmitz
#
#   This library is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public License
#   as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public License
#   along with this library; if not, write to the Free Software Founda-
#   tion, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
##
##  AUTHOR(S):	ks	Karl Schmitz <carolus.faber@googlemail.com>
##
##  WRITTEN BY:	ks	2013-02-14
##  CHANGED BY:	ks	2013-03-06	Attribute this to `libconf.sh'.
##		ks	2013-03-11	Work around mawk(1)'s misfeature of
##					aborting on nonexisting input files.
##----------------------------------------------------------------------------
##  Initialization:
#-----------------------------------------------------------------------------
BEGIN {
    ai = 0; ac = ARGC - 2; cfpn = ARGV[ac]
    while (++ai <= ac) {		## Foreach pathname argument do...
	av = ARGV[ai]; gsub("'", "&\\\\&&", av)
	if (system("test -f '" av "'")) delete ARGV[ai]
					## Delete it from ARGV[] if it doesn't
    }					## exist.

    re_ind	= "[ \t]*"		## Define RE building blocks for in-
    re_fld	= "[^ \t]+"		## dent, field (separator), comment,
    re_sep	= "[ \t]+"		## section header (with subsection).
    re_com	= "([#;].*)?"
    re_sec	= "\\[[^] \"[]+\\]"
    re_sub	= "\\[[^] \"[]+ \"[^\"]+\"\\]"

    re_l_com	= "^" re_ind re_com "$"	## Define corresponding syntax REs.
    re_l_sec	= "^" re_ind re_sec re_ind re_com "$"
    re_l_sub	= "^" re_ind re_sub re_ind re_com "$"
    re_l_sk2	= "^" re_ind re_fld re_sep re_fld

    ec = mc = sc = si = ai = 0
}

##----------------------------------------------------------------------------
##  has_si(SI)			Section index SI is alive?
##
##  NOTE:   (1)	si2vc[SI] is the section's VC, which may be deleted to kill a
##		section (whereas its sn2si[]/si2sn[] entries remain, allowing
##		to rebear the section under its old index).
##----------------------------------------------------------------------------
function has_si(si) {
    return (si in si2vc)
}

##----------------------------------------------------------------------------
##  get_si(SN)			Map section name SN to live SI (or 0), setting
##				`si'as a side-effect.
##----------------------------------------------------------------------------
function get_si(sn) {
    return ((si = sn2si[sn]) && (si in si2vc))
}

##----------------------------------------------------------------------------
##  set_si(SN)			Map section name SN to (new) SI, setting
##				`si' as a side-effect.
##----------------------------------------------------------------------------
function set_si(sn) {
    if (!(si = sn2si[sn])) {
	si = sn2si[sn] = ++sc; si2sn[si] = sn; si2vc[si] = 0
    } else if (!(si in si2vc)) {
	si2vc[si] = 0
    }
}

##----------------------------------------------------------------------------
##  has_vi(SI,VI)		Variable (SI,VI) is alive?
##
##  NOTE:   (1)	sivi2vv[SI,VI] is the variable's VV, which may be deleted to
##		unset a variable.
##----------------------------------------------------------------------------
function has_vi(si,vi) {
    return ((si,vi) in sivi2vv)
}

##----------------------------------------------------------------------------
##  get_vi(SI,VN)		Map variable name VN to live VI within SI,
##				setting `vi' as a side-effect.
##----------------------------------------------------------------------------
function get_vi(si,vn) {
    return ((vi = sivn2vi[si,vn]) && ((si,vi) in sivi2vv))
}

##----------------------------------------------------------------------------
##  set_vi(SI,VN)		Map variable name VN to (new) VI within SI,
##				setting `vi' as a side-effect.
##----------------------------------------------------------------------------
function set_vi(si,vn) {
    if (!(vi = sivn2vi[si,vn]) || (vi > si2vc[si])) {
					## VN not mapped in SI yet?
	vi = sivn2vi[si,vn] = ++si2vc[si]; sivi2vn[si,vi] = vn
    }					## Create VN <-> VI mappings.
}

##----------------------------------------------------------------------------
##  get_sn_vn(ITEM)		Split SECTION.VARIABLE into `sn' and `vn'.
##----------------------------------------------------------------------------
function get_sn_vn(item) {
    if (match(item, "^([^.]+\\.)+")) {
	sn = substr(item, RSTART, RLENGTH - 1)
	vn = substr(item, RSTART + RLENGTH)
    }
    return RSTART
}

function set_vv(si,vi,re) {
    match($0, re) && sivi2vv[si,vi] = substr($0, RSTART + RLENGTH + 1)
}

##----------------------------------------------------------------------------
##  Actions:
##----------------------------------------------------------------------------
($0 ~ re_l_com) {			## Empty or comment line!
    next				## Skip it.
}

($0 ~ re_l_sub) {			## Section header with subsection!
    if (match($0, re_sub)) {		## Line contains proper header?
	sn = substr($0, RSTART + 1, RLENGTH - 3)
	sub(" \"", ".", sn); set_si(sn)	## Map SN -> SI.
    } else {
	++ec				## Count error.
    }
    next
}

($0 ~ re_l_sec) {			## Section header!
    if (match($0, re_sec)) {		## Line contains proper header?
	sn = substr($0, RSTART + 1, RLENGTH - 2)
	set_si(sn)			## Map SN -> SI.
    } else {
	++ec				## Count error.
    }
    next
}

($0 ~ "^\t") && ($2 == "=") {		## Variable setting!
    if (!si) {				## Out-of-section?
	++ec				## Count error.
    } else {
	set_vi(si, $1); set_vv(si, vi, re_l_sk2)
    }
    next
}

($1 == "has") {				## `has' instruction!
    (get_sn_vn($2) && get_si(sn) && get_vi(si, vn)) || ++ec
    next
}

($1 == "get") {				## `get' instruction!
    dc = 0; if (get_sn_vn($2)) {
	if (sn != "*") {
	    if (get_si(sn) && get_vi(si, vn)) {
		print sivi2vv[si,vi]; ++dc
	    }
	} else for (si = 1; si <= sc; ++si) {
	    if (has_si(si) && get_vi(si, vn)) {
		print sivi2vv[si,vi]; ++dc
	    }
	}
    }
    dc || ++ec
    next
}

($1 == "set") {
    if (!get_sn_vn($2)) {
	++ec
    } else {
	set_si(sn); set_vi(si,vn); set_vv(si,vi,re_l_sk2)
	++mc
    }
    next
}

($1 == "unset") {
    if (get_sn_vn($2) && get_si(sn) && get_vi(si, vn)) {
	delete sivi2vv[si,vi]
	++mc
    }
    next
}

{					## None of the above!
    ++ec				## Count error.
    next
}

END {
    if (ec) exit 1
    if (mc) for (si = 1; si <= sc; ++si) if (has_si(si)) {
	sn = si2sn[si]; sub("\\.", " \"", sn) && sub("$", "\"", sn)
	printf("[%s]\n", sn) > cfpn
	for (vi = 1; vi <= si2vc[si]; ++vi) if (has_vi(si,vi))
	    printf("\t%s = %s\n", sivi2vn[si,vi], sivi2vv[si,vi]) > cfpn
    }
}
