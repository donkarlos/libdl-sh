#! /bin/sh ##
#-----------------------------------------------------------------------------
#   libquote.sh			- String quoting library
#
#   Copyright Â© 2013-2021 Das Computerlabor (DCl-M)
#
#   This library is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public License
#   as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public License
#   along with this library; if not, write to the Free Software Founda-
#   tion, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
##
##  AUTHOR(S):	ks	Karl Schmitz <ks@computerlabor.org>
##
##  WRITTEN BY:	ks	2013-02-13
##  CHANGED BY:	ks	2015-12-29	Implement meta operations.
##		ks	2016-05-19	Use meta prefix.
##		ks	2016-05-24	Add 'meta get package/version'.
##					Use 'meta get apis' separator ';'.
##		ks	2017-01-15	Update copyright.
##					Add 'meta session *'.
##		ks	2017-02-11	Make quote_sh() and quote_command()
##					process multi-line strings.
##		ks	2020-05-12	Limit valid 'meta session' operations.
##					Make 'meta get apis FORMAT' properly
##					handle namespace rule-exempted names.
##		ks	2021-04-29	Add universal quoter quote().
##		ks	2021-05-01	'set -u'-harden quote_meta().
##		ks	2021-05-08	Make 'quote_meta get apis' SEDEX
##					labels portable.
##		ks	2021-05-09	Overhaul quote_sh(), quote_command(),
##					quote_re(), quote_ere(), and
##					quote_rs().
##					'set -u'-harden quote_grep(), quote_-
##					egrep(), and quote_sed().
##					Introduce style aliases ore, bre,
##					ors, and brs.
##----------------------------------------------------------------------------
##  Global variables:
#-----------------------------------------------------------------------------
quote_package='@PACKAGE_TARNAME@'	## Define source package name/version.
quote_version='@PACKAGE_VERSION@'
quote_api=0				## Define API version.
quote_csl_sh=']})>?*'	quote_csr_sh='! 	$|&;#'"$BQ$DQ$SQ$BS$CR"'<({['
					## Define sh(1) spec. character set's
					## (sans '~') left/right halves.
quote_csl_bre=']'	quote_csr_bre='\.*['
					## Define obsolete/basic RE special
					## character set's (sans '^' and '$')
					## left/right halves.
quote_csl_ere0=']})^'	quote_csr_ere0='\.*|?+$({['
quote_csl_ere1=']})'	quote_csr_ere1='\.*|?+({['
					## Same for modern/extended REs.
quote_cs_brs='\&'			## Define 's///' right-hand side
					## special character set.
readonly quote_package quote_version quote_api quote_csl_sh quote_csr_sh\
	 quote_csl_bre quote_csr_bre					\
	 quote_csl_ere0 quote_csr_ere0 quote_csl_ere1 quote_csr_ere1	\
	 quote_cs_brs

##----------------------------------------------------------------------------
##  quote_meta(META [ARG ...])	Perform META operation (with ARGs)
##----------------------------------------------------------------------------
quote_meta() {
    local mp=quote_			## Set meta prefix.

    case ${2+=}${1+$1-}${2-} in		## Which META operation?
	=get-apis)			## Inquire APIs...
	    local sx ms=\;
	    local fa='/^a'"$ms"'/!d;s///' da='s/([^)'"$ms"'(]*)//'	\
		  ff='/^F'"$ms"'/{;s///;t2'"$NL"'};/^f'"$ms"'/!d;s///'	\
		  fr='/^R'"$ms"'/{;s///;t2'"$NL"'};/^r'"$ms"'/!d;s///'	\
		  p2=';s/'"$ms"'/&'"$mp"'/;:2'
	    case ${3-api} in		## Which format?
		api)	sx="$fa"			;;
		full)	sx="$ff$p2${4+$NL$4}"		;;
		list)	sx="$ff$p2$NL$da${4+;$4}"	;;
		r/o)	sx="$fr$p2${4+$NL$4}"		;;
		*)	return 1			;;
	    esac
	    sed "$sx" <<EOF
a${ms}$quote_api
f${ms}$quote_api${ms}meta(META [ARG ...])${ms}2-
F${ms}$quote_api${ms}quote([STYLE [DELIMITER]] ... STRING])${ms}0-
f${ms}$quote_api${ms}sh(STRING)${ms}1
f${ms}$quote_api${ms}command(COMMAND [ARGUMENT|REDIRECTION ...])${ms}1-
f${ms}$quote_api${ms}re(STRING [DELIMITER])${ms}1-2
f${ms}$quote_api${ms}ere(STRING [DELIMITER])${ms}1-2
f${ms}$quote_api${ms}rs(STRING [DELIMITER])${ms}1-2
f${ms}$quote_api${ms}grep(STRING)${ms}1
f${ms}$quote_api${ms}egrep(STRING)${ms}1
f${ms}$quote_api${ms}sed(STRING [DELIMITER=/])${ms}1-2
EOF
	    ;;
	=get-package|=get-version|=get-api)
					## Inquire internal variable...
	    eval 'case ${'"$mp$2"'+=} in
		=)  echo "$'"$mp$2"'"	;;
		*)  return 1		;;
	    esac'
	    ;;
	=session-init|=session-load|=session-dump|=session-exit)
	    :				## Session init/load/dump/exit...
	    ;;				## ...is a no-op.
	*)  return 2			## Anything else...
	    ;;				## ...is abuse!
    esac
}

##----------------------------------------------------------------------------
##  quote([[STYLE [DELIMITER]] ... STRING])
##				Universally quote STRING
##
##  Non-local variables:
##	- quote_csl_bre	(R) Special BRE character set sans '^' and '$',
##	- quote_csr_bre	(R) left and right half
##	- quote_cs_brs	(R) Special 's///' right-hand side character set
##	- quote_csl_sh	(R) Special sh(1) character set sans '~',
##	- quote_csr_sh	(R) left and right half
##----------------------------------------------------------------------------
quote() {
    local n st de string pass=1 cs sx=':N'"$NL"'$!{;N;bN'"$NL"'}'
					## Preset sed(1) expr. with "read all
					## lines into pattern buffer" loop.
    set shiftee ${1+"$@"}		## Let initial shift always succeed.
    while shift ${n-}; do		## Foreach style do...
	case ${2+2}${1+1}_${1+1$1_}${2+2$2_}${3+3} in
					## What are we looking at?
	    21_1[bo]r[es]_2?_3|21_1r[es]_2?_3|				\
	    21_1[bo]r[es]_2_3 |21_1r[es]_2_3 )
					## Style ([bo]?r[es]) with de-
					## limiter...
		n=2 st=$1 de=$2		## Fetch style and delimiter.
		;;
	    21_1*_2*_*)			## Style without delimiter...
		n=1 st=$1 de=		## Fetch style and (just in case)
		;;			## assume empty delimiter.
	    1_1*_)			## STRING...
		string=$1		## Fetch string.
		case ${st+=} in		## Already saw some style?
		    =)	break	;;	## Yes, let sed(1) do its thing!
		    *)	n=1	;;	## No, append implicit 'sh' pass.
		esac
		;;
	    _)				## No (more) arguments...
		break			## Let sed(1) do its thing!
		;;
	    *)				## Not really, but if...
		return 3		## Indicate internal error!
		;;
	esac; case ${st-sh} in		## Which style had been fetched?
	    ore|bre|re)			## Obsolete/Basic RE...
		cs=$quote_csl_bre${de-}$quote_csr_bre
		sx="$sx$NL"'s/['"$cs"']/\\&/g;s/^^/\\&/;s/$$/\\&/;s/'"$BS$NL"'/\\&/g'
					## Append "smart BRE quoting" state-
		;;			## ments.
	    ors|brs|rs)			## 's///' right-hand side...
		cs=$quote_cs_brs${de-}
		sx="$sx$NL"'s/['"$cs"']/\\&/g;s/'"$BS$NL"'/\\&/g'
					## Append "smart BRS quoting" state-
		;;			## ments.
	    sh)				## Bourne shell...
		cs=$quote_csl_sh$quote_csr_sh
		sx="$sx$NL"'/^$/bq'"$pass$NL"'/^~/bq'"$pass$NL"'/'"$BS$NL"'/bq'"$pass$NL"'/['"$cs"']/!be'"$pass$NL"':q'"$pass$NL"'s/'"$SQ"'/&'"$BS$BS"'&&/g;s/^/'"$SQ"'/;s/$/'"$SQ"'/;:e'"$pass"
		pass=`expr $pass + 1`	## Append "smart sh(1) quoting" state-
		;;			## ments.
	    *)	return 2		## Unknown style...
		;;			## Indicate abuse!
	esac
    done; sed "$sx$NL"'/^$/d' <<EOF
${string-}
EOF
}					## Ultimately, do the dirty deed. ;-)

##----------------------------------------------------------------------------
##  quote_sh(STRING)		Quote STRING for sh(1)
##
##  Non-local variables:
##	- quote_csl_sh	(R) Special sh(1) character set sans '~',
##	- quote_csr_sh	(R) left and right half
##----------------------------------------------------------------------------
quote_sh() {
    case ${2+2}${1+1} in		## Usage OK?
	1)  sed '
		:N'"$NL"'$!{;N;bN'"$NL"'}
		/^$/bq'"$NL"'/^~/bq'"$NL"'/'"$BS$NL"'/bq
		/['"$quote_csl_sh$quote_csr_sh"']/!q;:q
		s/'"$SQ"'/&'"$BS$BS"'&&/g;s/^/'"$SQ"'/;s/$/'"$SQ"'/
	    ' <<EOF
$1
EOF
	    ;;				## Yes, quote for sh(1).
	*)  return 2			## No, indicate abuse!
	    ;;
    esac
}

##----------------------------------------------------------------------------
##  quote_command(COMMAND [ARGUMENT|REDIRECTION ...])
##				Quote sh(1) command
##----------------------------------------------------------------------------
quote_command() {
    case ${1+1} in			## Usage OK?
	1)  local cmd="$1" arg	;;	## Yes, fetch command.
	*)  return 2		;;	## No, indicate abuse!
    esac; shift; for arg in ${1+"$@"}; do
	case $arg in			## Foreach argument/redirection do...
	    *\<*|*\>*)			## Redirection?
		cmd="$cmd $arg"		## Yes, append it literally.
		;;
	    *)  cmd="$cmd `quote_sh "$arg"`" || break
		;;			## No, append sh(1)-quoted argument.
	esac
    done && echo "$cmd"			## Emit quoted command.
}

##----------------------------------------------------------------------------
##  quote_re(STRING [DELIMITER])
##				Quote STRING for use as obsolete/basic RE
##
##  Non-local variables:
##	- quote_csl_bre	(R) Special BRE character set sans '^' and '$',
##	- quote_csr_bre	(R) left and right half
##----------------------------------------------------------------------------
quote_re() {
    case ${3+3}${2+2$2_}${1+1} in	## Usage OK/delimiter OK?
	2?_1|1)				## Y/Y: Quote basic RE.
	    sed '
		:N'"$NL"'$!{;N;bN'"$NL"'}
		s/['"$quote_csl_bre${2-}$quote_csr_bre"']/\\&/g
		s/^^/\\&/;s/$$/\\&/;s/'"$BS$NL"'/\\&/g
	    ' <<EOF
$1
EOF
			;;
	2*) return 1	;;		## Y/N: Indicate failure!
	*)  return 2	;;		## N/?: Indicate abuse!
    esac
}

##----------------------------------------------------------------------------
##  quote_ere(STRING [DELIMITER])
##				Quote STRING for use as modern/extended RE
##----------------------------------------------------------------------------
quote_ere() {
    case ${3+3}${2+2$2_}${1+1} in	## Usage OK/delimiter OK?
	2?_1|1)				## Y/Y: Quote basic RE.
	    sed '
		:N'"$NL"'$!{;N;bN'"$NL"'}
		s/['"$quote_csl_ere1${2-}$quote_csr_ere1"']/\\&/g
		s/^^/\\&/;s/$$/\\&/;s/'"$BS$NL"'/\\&/g
	' <<EOF
$1
EOF
			;;
	2*) return 1	;;		## Y/N: Indicate failure!
	*)  return 2	;;		## N/?: Indicate abuse!
    esac
}

##----------------------------------------------------------------------------
##  quote_rs(STRING [DELIMITER=/])
##				Quote STRING for use as sed(1) 's///' substi-
##				tution
##----------------------------------------------------------------------------
quote_rs() {
    case ${3+3}${2+2$2_}${1+1} in	## Usage OK/delimiter OK?
	2?_1|1)				## Y/Y: Quote 's///' substitution.
	    sed '
		:N'"$NL"'$!{;N;bN'"$NL"'}
		s/['"$quote_cs_brs${2-/}"']/\\&/g
		s/'"$BS$NL"'/\\&/g
	    ' <<EOF
$1
EOF
			;;
	2*) return 1	;;		## Y/N: Indicate failure!
	*)  return 2	;;		## N/?: Indicate abuse!
    esac
}

##----------------------------------------------------------------------------
##  quote_grep(STRING)		Quote STRING for grep(1)
##----------------------------------------------------------------------------
quote_grep() {
    case ${2+2}${1+1} in		## Usage OK?
	1)  quote_re "$1"   ;;		## Yes, let quote_re() do the work.
	*)  return 2	    ;;		## No, indicate abuse!
    esac
}

##----------------------------------------------------------------------------
##  quote_egrep(STRING)		Quote STRING for egrep(1)
##----------------------------------------------------------------------------
quote_egrep() {
    case ${2+2}${1+1} in		## Usage OK?
	1)  quote_ere "$1"  ;;		## Yes, let quote_ere() do the work.
	*)  return 2	    ;;		## No, indicate abuse!
    esac
}

##----------------------------------------------------------------------------
##  quote_sed(STRING [DELIMITER=/])
##				Quote STRING for sed(1)
##----------------------------------------------------------------------------
quote_sed() {
    case ${3+3}${2+2$2_}${1+1} in	## Usage OK/delimiter OK?
	2?_1|1)				## Y/Y: Let quote_re() do the work.
	    quote_re "$1" "${2-/}"
			;;
	2*) return 1	;;		## Y/N: Indicate failure!
	*)  return 2	;;		## N/?: indicate abuse!
    esac
}
