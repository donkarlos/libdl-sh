#! /usr/bin/awk -f
#-----------------------------------------------------------------------------
#   args.awk			- Command-line option parser
#
#   Copyright Â© 2018-2020 Das Computerlabor (DCl-M)
#
#   This library is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public License
#   as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public License
#   along with this library; if not, write to the Free Software Founda-
#   tion, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
##
##  AUTHOR(S):	ks	Karl Schmitz <ks@computerlabor.org>
##
##  WRITTEN BY:	ks	2018-03-03
##  CHANGED BY:	ks	2020-05-14	Update copyright notice.
##					Move initialization to front.
##					Trace argument types symbolically.
##					Print error messages with error().
##					Also trace to stderr.
##
##  Global constants and variables:
##	- DEBUG		Debugging flag (set with '-vDEBUG=1')
##	- FALSE/TRUE	Boolean constants
##	- stderr	Portably print to standard error output
##	- legacy	Legacy mode flag
##	- posixish	POSIX compliancy flag
##	- ordered	Ordered output mode flag
##	- AT_{ERR,EOA,EOO,ARG,ONA,OOA,ORA}
##			Argument/option type indices returned by getopt_next()
##			denoting
##			  * ERRor,
##			  * End Of Arguments,
##			  * End Of Options ("--"),
##			  * (non-option) ARGument,
##			  * Option with No/Optional/Required Argument
##			(The latter three being the option type subset)
##	- at2sy[AT]	Argument type -> symbol map
##	- dl2at[DL]	Short option descriptor's length -> option type map
##	- at2ds[AT]	Option type -> descriptor suffix map
##	- pi2oc[PI]	Per-pass option count (i.e., 1 <= OI <= pi2oc[PI])
##	- pion2oi[PI,ON] Per-pass option name -> index map
##			 (also used for long options' abbreviations)
##	- pioi2on[PI,OI] Per-pass option index -> name map
##	- pioi2at[PI,OI] Per-pass option index -> type map
##			 (uses subset AT_{ONA,OOA,ORA})
##	- piow2ov[PI,"a"]
##			Per-pass alternative long options flag
##	- piow2ov[PI,"n"]
##			Per-pass command name
##	- piow2ov[PI,"o"]
##			Per-pass OPTSTRING count
##	- piow2ov[PI,"q"]
##			Per-pass quiet flag (i.e., suppress error messages)
##	- piow2ov[PI,"Q"]
##			Per-pass suppress output flag
##	- piow2ov[PI,"u"]
##			Per-pass unquoted output flag
##	- piow2ov[PI,"s"]
##			Per-pass shell
##	- nesting	Nesting depth
##----------------------------------------------------------------------------
##  Initialization:
#-----------------------------------------------------------------------------
BEGIN {
    FALSE = 0; TRUE = !FALSE		## Define booleans.

    stderr = "cat >&2"			## Portable stderr.

    at				= -4	## Enumerate argument types...
    at2sy[AT_ERR = ++at]	= "AT_ERR"
    at2sy[AT_EOA = ++at]	= "AT_EOA"
    at2sy[AT_EOO = ++at]	= "AT_EOO"
    at2sy[AT_ARG = ++at]	= "AT_ARG"
    at2sy[AT_ONA = ++at]	= "AT_ONA"
    at2sy[AT_OOA = ++at]	= "AT_OOA"
    at2sy[AT_ORA = ++at]	= "AT_ORA"

    at2ds[dl2at[++dl] = AT_ONA]	= ""	## Preset option type -> descriptor
    at2ds[dl2at[++dl] = AT_ORA]	= ":"	## suffix and short option descrip-
    at2ds[dl2at[++dl] = AT_OOA]	= "::"	## tor's length -> option type maps
}					## in one go!

##----------------------------------------------------------------------------
##  enter(FN,FP)		Trace entry into function FN with sprintf()-
##				formatted parameter list FP to stderr and
##				increase nesting depth
##
##  Global variables:
##	- stderr	(R) Portable stderr (pipe handle)
##	- nesting	(W) Nesting depth
##  Local variables:
##	- fmt		(R) Printf() format
##----------------------------------------------------------------------------
function enter(fn,fp ,fmt) {
    if (DEBUG) {
	fmt = sprintf("#%%%us%%s(%%s)\n",nesting++)
	printf fmt,"",fn,fp | stderr
    }
}

##----------------------------------------------------------------------------
##  trace(EX)			Trace sprintf()-formatted EXpression to stderr
##
##  Global variables:
##	- stderr	(R) Portable stderr (pipe handle)
##	- nesting	(R) Nesting depth
##  Local variables:
##	- fmt		(R) Printf() format
##----------------------------------------------------------------------------
function trace(ex ,fmt) {
    if (DEBUG) {
	fmt = sprintf("#%%%us%%s\n",nesting); printf fmt,"",ex | stderr
    }
}

##----------------------------------------------------------------------------
##  leave(RV)			Trace leave from function with sprintf()-
##				formatted return value RV to stderr and
##				decrease nesting depth
##
##  Global variables:
##	- stderr	(R) Portable stderr (pipe handle)
##	- nesting	(W) Nesting depth
##  Local variables:
##	- fmt		(R) Printf() format
##----------------------------------------------------------------------------
function leave(rv ,fmt) {
    if (DEBUG) {
	fmt = sprintf("#%%%usreturn(%%s)\n",--nesting)
	printf fmt,"",rv | stderr
    }
}

##----------------------------------------------------------------------------
##  error(MESSAGE,PI)		Print sprintf()-formatted MESSAGE on stderr
##				unless PI-th pass is quiet
##
##  Global variables:
##	- stderr	(R) Portable stderr (pipe handle)
##	- piow2ov[PI,"n"]
##			(R) Per-pass command name
##	- piow2ov[PI,"q"]
##			(R) Per-pass quiet flag
##----------------------------------------------------------------------------
function error(message,pi) {
    if (!piow2ov[pi,"q"]) {		## PI-th pass is quiet?
	print piow2ov[pi,"n"] ": " message | stderr
					## No, print MESSAGE (prefixed with
    }					## pass's command name) on stderr.
}

##----------------------------------------------------------------------------
##  quote_sh(STRING,PI)		Conditionally quote STRING
##----------------------------------------------------------------------------
function quote_sh(string,pi) {
    if (!legacy && !piow2ov[pi,"u"]) {	## Must quote STRING?
	gsub(/'/,"&\\\\&&",string); string = "'" string "'"
    }					## Yes, do so.
    return string
}

##----------------------------------------------------------------------------
##  getopt_add_optstring(OPTSTRING,PI)
##				Add short options described by OPTSTRING to
##				PI-th pass
##----------------------------------------------------------------------------
function getopt_add_optstring(optstring,pi ,ow,on,at,oi) {
    enter("getopt_add_optstring",sprintf("optstring=\"%s\",pi=%u",	\
	optstring,pi))
    while (optstring) {			## While OPTSTRING is non-empty do...
	if (!match(optstring,/^[^-:]:?:?/)) {
					## Looking at valid descriptor?
	    error(sprintf("'%s' describes no short option!",optstring),pi)
	    leave(1); return 1		## No, complain and indicate failure!
	}
	ow = substr(optstring,1,1); on = "-" ow; at = dl2at[RLENGTH]
	trace(sprintf("ow=\"%s\";on=\"%s\";at=%s",ow,on,at2sy[at]))
					## Derive option word, name, and
					## type from descriptor.
	if (!(oi = pion2oi[pi,on])) {	## Short option unregistered so far?
	    pioi2on[pi,oi = pion2oi[pi,on] = ++pi2oc[pi]] = on
	    pioi2at[pi,oi] = at		## Yes, register short option.
	    trace(sprintf("pioi2on[pi=%u,oi=pion2oi[pi,on]=%u]=on;"	\
		"pioi2at[pi,oi]=at",pi,oi))
	} else if (at != pioi2at[pi,oi]) {
					## No, and registered differently?
	    error(sprintf("'%s' already registered by '%s%s'!",on,ow,	\
		at2ds[pioi2at[pi,oi]]),pi)
	    leave(1); return 1		## Yes, complain and indicate failure!
	}
	optstring = substr(optstring,1+RLENGTH)
	trace(sprintf("optstring=\"%s\"",optstring))
    }					## Consume descriptor.
    leave(0); return 0			## Indicate success.
}

##----------------------------------------------------------------------------
##  getopt_add_longopts(LONGOPTS,PI)
##				Add long options described by LONGOPTS's to
##				PI-th pass
##----------------------------------------------------------------------------
function getopt_add_longopts(longopts,pi ,di,dc,dv,cp,ow,on,at,oi) {
    enter("getopt_add_longopts",sprintf("longopts=\"%s\",pi=%u",longopts,pi))
    di = 0; dc = split(longopts,dv,/,/)	## Split LONGOPTS into descriptors.
    while (++di <= dc) {		## Foreach descriptor do...
	if (!match(dv[di],/^[^-=:]+(-[^-=:]+)*:?:?$/)) {
					## Description is valid?
	    error(sprintf("'%s' describes no long option!",dv[di]),pi)
	    leave(1); return 1		## No, complain and indicate failure!
	}
	if (!(cp = index(dv[di],":"))) cp = RLENGTH + 1
	ow = substr(dv[di],1,cp-1); on = "--" ow; at = dl2at[2+RLENGTH-cp]
	trace(sprintf("ow=\"%s\";on=\"%s\";at=%s",ow,on,at2sy[at]))
					## Derive colon position as well as
					## option word, name, and type from
					## descriptor.
	if (!(oi = pion2oi[pi,on]) || (on < pioi2on[pi,oi])) {
					## Long option so far unregistered or
					## registered as abbreviation?
	    pioi2on[pi,oi = pion2oi[pi,on] = ++pi2oc[pi]] = on
	    pioi2at[pi,oi] = at		## Yes, register long option.
	    trace(sprintf("pioi2on[pi=%u,oi=pion2oi[pi,on]=%u]=on;"	\
		"pioi2at[pi,oi]=at",pi,oi))
	} else if (at != pioi2at[pi,oi]) {
					## No, and registered differently?
	    error(sprintf("'%s' already registered by '%s%s'!",on,ow,	\
		at2ds[pioi2at[pi,oi]]),pi)
	    leave(1); return 1		## Yes, complain and indicate failure!
	}

	while (cp > 2) {		## Foreach abbreviation do...
	    if (!pion2oi[pi,on = substr(on,1,cp--)]) {
					## Abbreviation is unregistered?
		pion2oi[pi,on] = oi	## Yes, register abbreviation.
		trace(sprintf("pion2oi[%u,\"%s\"]=%u",pi,on,oi))
	    } else if ((oi = pion2oi[pi,on]) < 0) {
					## Abbreviation was ambiguous?
		break			## Yes, so its prefices are, too!
	    } else if (pioi2on[pi,oi] != on) {
					## Abbreviation is ambiguous?
		pion2oi[pi,on] = -1	## Yes, indicate so.
		trace(sprintf("pion2oi[%u,\"%s\"]=-1",pi,on))
	    }
	}
    }
    leave(0); return 0			## Indicate success.
}

##----------------------------------------------------------------------------
##  getopt_next(PI)		Fetch next option/argument in PI-th pass
##----------------------------------------------------------------------------
function getopt_next(pi ,on,ov,oi,at,ep) {
    enter("getopt_next",sprintf("pi=%u",pi))
    if (++ARGI >= ARGC) {		## Arguments exhausted?
	leave(at2sy[AT_EOA]); return AT_EOA
    }					## Yes, indicate so.

    trace(sprintf("ARGV[%u]=\"%s\"",ARGI,ARGV[ARGI]))
    if (match(ARGV[ARGI],/^-[^-]/)) {	## Looking at short option?
	on = substr(ARGV[ARGI],RSTART,RLENGTH)
	ov = substr(ARGV[ARGI],RSTART+RLENGTH)
					## Yes, split it into name/value.
	if (oi = pion2oi[pi,on]) {	## Registered for PI-th pass?
	    at = pioi2at[pi,oi]		## Yes, fetch argument type.
	    if (ov) {			## Value attached?
		if (at >= AT_OOA) {	## Yes, and option wants value?
		    at = AT_ORA		## Yes, supply it.
		} else {		## No, push back glued short options.
		    trace(sprintf("ARGV[%u]=\"-%s\"",ARGI,ov))
		    ARGV[ARGI--] = "-" ov
		}
	    } else {			## No value attached!
		if (at <= AT_OOA) {	## Option requires value?
		    at = AT_ONA		## No, don't supply any.
		} else if (++ARGI < ARGC) {
					## Another argument follows?
		    ov = ARGV[ARGI]	## Yes, supply that as value.
		} else {
		    error(sprintf("%s: Missing value!",on),pi)
		    leave(at2sy[AT_ERR]); return AT_ERR
		}			## No, complain and indicate failure!
	    }
	    trace(sprintf("OPTNAM=\"%s\";OPTVAL=\"%s\"",on,ov))
	    leave(at2sy[at]); OPTNAM = on; OPTVAL = ov; return at
	} else if (!piow2ov[pi,"a"] || (ARGV[ARGI] !~ /^(-[^-=]+)+/)) {
					## Alternative long options allowed
					## and option looks like that?
	    if (!piow2ov[pi,"q"]) printf "%s: %s: Unknown option!\n",
		piow2ov[pi,"n"],on | stderr
	    leave(at2sy[AT_ERR]); return AT_ERR
	}				## No, complain and indicate failure!
	ARGV[ARGI] = "-" ARGV[ARGI]	## Fake long option.
	trace(sprintf("ARGV[ARGI=%u]=\"%s\"",ARGI,ARGV[ARGI]))
    }
    if (match(ARGV[ARGI],/^-(-[^-=]+)+/)) {
					## Looking at long option?
	on = substr(ARGV[ARGI],RSTART,RLENGTH)
	trace(sprintf("on=\"%s\"",on))
					## Yes, derive name.
	if (!(oi = pion2oi[pi,on])) {	## Registered for PI-th pass?
	    if (!piow2ov[pi,"q"]) printf "%s: %s: Unknown option!\n",
		piow2ov[pi,"n"],on | stderr
	    leave(at2sy[AT_ERR]); return AT_ERR
					## No, complain and indicate failure!
	} else if (oi < 0) {		## Unambiguous?
	    if (!piow2ov[pi,"q"]) printf "%s: %s: Ambiguous option!\n",
		piow2ov[pi,"n"],on | stderr
	    leave(at2sy[AT_ERR]); return AT_ERR
	}				## No, complain and indicate failure!
	at = pioi2at[pi,oi]		## Fetch argument type and unabbrevi-
	on = pioi2on[pi,oi]		## ated name.
	if (ep = index(ARGV[ARGI],"=")) {
					## Value attached?
	    if (at >= AT_OOA) {		## Option wants value?
		at = AT_ORA; ov = substr(ARGV[ARGI],ep+1)
	    } else {			## Yes, supply it.
		if (!piow2ov[pi,"q"])
		    printf "%s: %s: Excess value (ignored).\n",
			piow2ov[pi,"n"],on | stderr
	    }				## No, warn about excess value.
	} else {			## No, value attached!
	    if (at <= AT_OOA) {		## Option requires value?
		at = AT_ONA		## No, don't supply any.
	    } else if (++ARGI < ARGC) {	## Another argument follows?
		ov = ARGV[ARGI]		## Yes, supply that as value.
	    } else {
		if (!piow2ov[pi,"q"]) printf "%s: %s: Missing value!\n",
			piow2ov[pi,"n"],on | stderr
		leave(at2sy[AT_ERR]); return AT_ERR
	    }				## No, complain and indicate failure!
	}
	trace(sprintf("OPTNAM=\"%s\";OPTVAL=\"%s\"",on,ov))
	leave(at2sy[at]); OPTNAM = on; OPTVAL = ov; return at
    }
    if (ARGV[ARGI] == "--") {		## Looking at end-of-option marker?
	++ARGI; leave(at2sy[AT_EOO]); return AT_EOO
    }					## Yes, consume and return it.
    leave(at2sy[AT_ARG]); return AT_ARG
}

##----------------------------------------------------------------------------
##  args_print()		Print command line parameters
##----------------------------------------------------------------------------
function args_print() {
    for (ARGI = 0; ARGI < ARGC; ++ARGI)
	printf "ARGV[%u]=\"%s\"\n",ARGI,ARGV[ARGI]
    printf "ARGC=%u\n",ARGC; return 0
}

##----------------------------------------------------------------------------
##  args_getopt(CN)		Emulate getopt(1)
##----------------------------------------------------------------------------
function args_getopt(cn ,at,O,A) {
    enter("args_getopt",sprintf("cn=\"%s\"",cn))
    pi = 1				## Begin with 1st pass.
    piow2ov[pi+1,"n"] = piow2ov[pi,"n"] = cn
    trace(sprintf("piow2ov[%u,\"n\"]=piow2ov[%u,\"n\"]=\"%s\"",pi+1,pi,cn))
					## Preset pass' command name.
    if ("GETOPT_COMPATIBLE" in ENVIRON) {
					## Env. var. GETOPT_COMPATIBLE set?
	++legacy			## Yes, force legacy mode.
	trace(sprintf("legacy=%u",legacy))
    } else {				## No, register getopt(1) options.
	getopt_add_optstring("ahl:n:o:qQs:uTV",pi)
	getopt_add_longopts("alternative,help,longoptions:,name:,options:",pi)
	getopt_add_longopts("quiet,quiet-output,shell:,unquoted,test,version",pi)
    }

    for (;;) {				## While parsing getopt(1) options...
	if (legacy) {			## In legacy mode?
	    ++ARGI; ++pi; break		## Yes, skip 1st pass entirely!
	} else if ((at = getopt_next(pi)) <= AT_ARG) {
					## getopt(1) options consumed?
	    ++pi; break			## Yes, leave 1st pass.
	} else if (OPTNAM ~ /^(-a|--alternative)$/) {
	    ++piow2ov[pi+1,"a"]		## Allow alternative long options.
	    trace(sprintf("piow2ov[%u,\"a\"]=%u",pi+1,piow2ov[pi+1,"a"]))
	} else if (OPTNAM ~ /^(-l|--longoptions)$/) {
	    if (getopt_add_longopts(OPTVAL,pi+1)) {
		leave(1); return 1
	    }				## Try to add LONGOPTS for command.
	} else if (OPTNAM ~ /^(-n|--name)$/) {
	    piow2ov[pi+1,"n"] = OPTVAL	## Update command name.
	    trace(sprintf("piow2ov[%u,\"n\"]=\"%s\"",pi+1,piow2ov[pi+1,"n"]))
	} else if (OPTNAM ~ /^(-o|--options)$/) {
	    if (getopt_add_optstring(OPTVAL,pi+1)) {
		leave(1); return 1
	    }
	    ++piow2ov[pi+1,"o"]		## Try to add OPTSTRING for command.
	    trace(sprintf("piow2ov[%u,\"o\"]=%u",pi+1,piow2ov[pi+1,"o"]))
	} else if (OPTNAM ~ /^(-q|--quiet)$/) {
	    ++piow2ov[pi+1,"q"]		## Become quiet.
	    trace(sprintf("piow2ov[%u,\"q\"]=%u",pi+1,piow2ov[pi+1,"q"]))
	} else if (OPTNAM ~ /^(-Q|--quiet-output)$/) {
	    ++piow2ov[pi+1,"Q"]		## Don't print result.
	    trace(sprintf("piow2ov[%u,\"Q\"]=%u",pi+1,piow2ov[pi+1,"Q"]))
	} else if (OPTNAM ~ /^(-s|--shell)$/) {
	    if (OPTVAL ~ /^([bd]?a|[ck])?sh$/) {
		piow2ov[pi+1,"s"] = OPTVAL
					## Update command's shell.
		trace(sprintf("piow2ov[%u,\"s\"]=\"%s\"",pi+1,		\
		    piow2ov[pi+1,"s"]))
	    } else {
		if (!piow2ov[pi+1,"q"]) printf "%s: '%s' is no shell!\n",
			piow2ov[pi,"n"],OPTVAL | stderr
	    }
	} else if (OPTNAM ~ /^(-u|--unquoted)$/) {
	    ++piow2ov[pi+1,"u"]		## Force unquoted output.
	    trace(sprintf("piow2ov[%u,\"u\"]=%u",pi+1,piow2ov[pi+1,"u"]))
	}
    }

    if (at < AT_EOA) {
	leave(1); return 1		## Pass any failure through.
    }
    if (!piow2ov[pi,"o"]) {		## Any OPTSTRING seen so far?
	if (ARGI < ARGC) {		## No, but looking at OPTSTRING now?
	    if (ARGI == 2) ++legacy	## Yes, force legacy mode on legacy
					## invocation and try...
	    if (getopt_add_optstring(ARGV[ARGI++],pi)) {
		leave(1); return 1
	    }				## ...to add OPTSTRING for 2nd pass.
	} else {			## OPTSTRING is missing.
	    if (!piow2ov[pi,"q"])
		printf "Usage: %s [OPTIONS] OPTSTRING [ARG ...]\n",
		    piow2ov[pi,"n"] | stderr
	    leave(2); return 2		## Complain and indicate usage error!
	}
    }

    --ARGI; while ((at = getopt_next(pi)) > AT_EOO) {
					## While processing command's
					## arguments do...
	if (DEBUG) trace(sprintf("at=%d",at))
	if (at < AT_ONA) {		## Saw argument?
	    A = A " " quote_sh(ARGV[ARGI],pi)
					## Yes, quote and append it.
	} else if (at == AT_ONA) {	## Saw option without value?
	    O = O quote_sh(OPTNAM,pi) " "
					## Yes, quote and append it.
	} else {			## Saw option with value!
	    O = O quote_sh(OPTNAM,pi) " " quote_sh(OPTVAL,pi) " "
					## Quote and append it as well as
	}				## its value.
    }
    if (DEBUG) trace(sprintf("at=%d",at))

    if (at < AT_EOA) {
	leave(1); return 1		## Pass any failure through.
    }
    if (at == AT_EOO) while (ARGI < ARGC) A = A " " quote_sh(ARGV[ARGI++],pi)
					## Quote and append remaining
					## arguments.
    if (!piow2ov[pi,"Q"]) printf "%s--%s\n",O,A
    leave(0); return 0			## Indicate success.
}

##----------------------------------------------------------------------------
##  Main program:
##----------------------------------------------------------------------------
BEGIN {
    if (ARGV[ARGI=1] == "print") {	## Which action?
	args_print()			## Print arguments.
    } else if (ARGV[ARGI] == "getopt") {
	args_getopt(ARGV[ARGI])		## Emulate getopt(1).
    } else {
	printf "%s: unknown action '%s'!\n",
	    piow2ov[pi,"n"],ARGV[ARGI] | stderr
    }
}
