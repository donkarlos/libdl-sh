#! /usr/bin/awk -f
#-----------------------------------------------------------------------------
#   args.awk			- Command-line option parser
#
#   Copyright Â© 2018-2020 Das Computerlabor (DCl-M)
#
#   This library is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public License
#   as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public License
#   along with this library; if not, write to the Free Software Founda-
#   tion, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
##
##  AUTHOR(S):	ks	Karl Schmitz <ks@computerlabor.org>
##
##  WRITTEN BY:	ks	2018-03-03
##  CHANGED BY:	ks	2020-05-14	Update copyright notice.
##					Move initialization to front.
##					Trace argument types symbolically.
##					Print error messages with error().
##					Also trace to stderr.
##			2020-05-15	Use system("echo '...' >&2").
##
##  Global constants and variables:
##	- DEBUG		Debugging flag (set with '-vDEBUG=1')
##	- FALSE/TRUE	Boolean constants
##	- compatible	Compatibility mode flag
##	- posixly	POSIX compliancy flag
##	- ordered	Ordered output flag
##	- AT_{ERR,EOA,EOO,ARG,ONA,OOA,ORA}
##			Argument/option type indices returned by
##			getopt_shift() denoting
##			  * ERRor,
##			  * End Of Arguments,
##			  * End Of Options ("--"),
##			  * (non-option) ARGument,
##			  * Option with No/Optional/Required Argument
##			(The latter three being the option type subset)
##	- at2sy[AT]	Argument type -> symbol map
##	- dl2at[DL]	Short option descriptor's length -> option type map
##	- at2ds[AT]	Option type -> descriptor suffix map
##	- pi2oc[PI]	Per-pass option index -> name map's size
##	- pion2oi[PI,ON] Per-pass option name -> index map
##			 (also used for long options' abbreviations)
##	- pioi2on[PI,OI] Per-pass option index -> name map
##	- pioi2at[PI,OI] Per-pass option index -> type map
##			 (uses subset AT_{ONA,OOA,ORA})
##	- piow2ov[PI,"a"]
##			Per-pass alternative long options flag
##	- piow2ov[PI,"n"]
##			Per-pass command name
##	- piow2ov[PI,"o"]
##			Per-pass OPTSTRING count
##	- piow2ov[PI,"q"]
##			Per-pass quiet flag (i.e., suppress error messages)
##	- piow2ov[PI,"Q"]
##			Per-pass suppress output flag
##	- piow2ov[PI,"u"]
##			Per-pass unquoted output flag
##	- piow2ov[PI,"s"]
##			Per-pass shell
##	- nesting	Nesting depth
##----------------------------------------------------------------------------
##  Initialization:
#-----------------------------------------------------------------------------
BEGIN {
    FALSE = 0; TRUE = !FALSE		## Define booleans.

    at				= -4	## Enumerate argument types...
    at2sy[AT_ERR = ++at]	= "AT_ERR"
    at2sy[AT_EOA = ++at]	= "AT_EOA"
    at2sy[AT_EOO = ++at]	= "AT_EOO"
    at2sy[AT_ARG = ++at]	= "AT_ARG"
    at2sy[AT_ONA = ++at]	= "AT_ONA"
    at2sy[AT_OOA = ++at]	= "AT_OOA"
    at2sy[AT_ORA = ++at]	= "AT_ORA"

    at2ds[dl2at[++dl] = AT_ONA]	= ""	## Preset option type -> descriptor
    at2ds[dl2at[++dl] = AT_ORA]	= ":"	## suffix and short option descrip-
    at2ds[dl2at[++dl] = AT_OOA]	= "::"	## tor's length -> option type maps
}					## in one go!

##----------------------------------------------------------------------------
##  enter(FN,FP)		Trace entry into function FN with sprintf()-
##				formatted parameter list FP to stderr and
##				increase nesting depth
##  Global variables:
##	- nesting	(W) Nesting depth
##  Local variables:
##	- fmt		(W) Format string
##	- msg		(W) Quoted message
##----------------------------------------------------------------------------
function enter(fn,fp ,fmt,msg) {
    if (DEBUG) {
	fmt = sprintf("#%%%us%%s(%%s)",nesting++)
					## Construct format string.
	msg = sprintf(fmt,"",fn,fp); gsub(/'/,"&\\\\&&",msg)
					## Construct quoted message and
	system("echo '" msg "' >&2")	## emit it to stderr.
    }
}

##----------------------------------------------------------------------------
##  trace(EX)			Trace sprintf()-formatted EXpression to stderr
##
##  Global variables:
##	- nesting	(R) Nesting depth
##  Local variables:
##	- fmt		(W) Format string
##	- msg		(W) Quoted message
##----------------------------------------------------------------------------
function trace(ex ,fmt,msg) {
    if (DEBUG) {
	fmt = sprintf("#%%%us%%s",nesting)
					## Construct format string.
	msg = sprintf(fmt,"",ex); gsub(/'/,"&\\\\&&",msg)
					## Construct quoted message and
	system("echo '" msg "' >&2")	## emit it to stderr.
    }
}

##----------------------------------------------------------------------------
##  leave(RV)			Trace leave from function with sprintf()-
##				formatted return value RV to stderr and
##				decrease nesting depth
##  Global variables:
##	- nesting	(W) Nesting depth
##  Local variables:
##	- fmt		(W) Format string
##	- msg		(W) Quoted message
##----------------------------------------------------------------------------
function leave(rv ,fmt,msg) {
    if (DEBUG) {
	fmt = rv ? sprintf("#%%%usreturn(%%s)",--nesting)		\
		 : sprintf("#%%%usreturn%%s",  --nesting)
					## Construct format string.
	msg = sprintf(fmt,"",rv); gsub(/'/,"&\\\\&&",msg)
					## Construct quoted message and
	system("echo '" msg "' >&2")	## emit it to stderr.
    }
}

##----------------------------------------------------------------------------
##  error(MSG,PI)		Emit sprintf()-formatted error message MSG
##				on stderr unless PI-th pass is quiet
##  Global variables:
##	- piow2ov[PI,"n"]
##			(R) Per-pass command name
##	- piow2ov[PI,"q"]
##			(R) Per-pass quiet flag
##----------------------------------------------------------------------------
function error(msg,pi) {
    if (!piow2ov[pi,"q"]) {		## PI-th pass is quiet?
	sub(/^/,piow2ov[pi,"n"] ": ",msg); gsub(/'/,"&\\\\&&",msg)
					## No, construct quoted message and
	system("echo '" msg "' >&2")	## emit it to stderr.
    }
}

##----------------------------------------------------------------------------
##  quote_sh(STRING,PI)		Conditionally sh(1)-quote STRING
##
##  Global variables:
##	- piow2ov[PI,"u"]
##			(R) Per-pass unquoted output flag
##----------------------------------------------------------------------------
function quote_sh(string,pi) {
    enter("quote_sh",sprintf("string=\"%s\",pi=%u",string,pi))
    if (!piow2ov[pi,"u"]) {		## Must quote STRING?
	gsub(/'/,"&\\\\&&",string); string = "'" string "'"
    }					## Yes, do so.
    leave("\"" string "\""); return string
}

##----------------------------------------------------------------------------
##  getopt_add_optstring(OPTSTRING,PI)
##				Add short options described by OPTSTRING to
##				PI-th pass
##  Global variables:
##	- compatible	(R) Compatibility mode flag
##	- posixly	(W) POSIX compliancy flag
##	- ordered	(W) Ordered output flag
##	- RSTART	(W) match() start position
##	- RLENGTH	(W) match() length
##	- at2sy[AT]	(R) Argument type -> symbol map
##	- dl2at[DL]	(R) Short option descriptor's length -> type map
##	- at2ds[AT]	(R) Option type -> descriptor suffix map
##	- pi2oc[PI]	(W) Per-pass option index -> name map's size
##	- pion2oi[PI,ON](W) Per-pass option name -> index map
##	- pioi2on[PI,OI](W) Per-pass option index -> name map
##	- pioi2at[PI,OI](W) Per-pass option index -> type map
##  Local variables:
##	- re		(R) Mode-specific short option descriptor RE
##	- ow		(W) Option word
##	- on		(W) Option name
##	- at		(W) Option type
##	- oi		(W) Option index
##----------------------------------------------------------------------------
function getopt_add_optstring(optstring,pi ,re,ow,on,at,oi) {
    enter("getopt_add_optstring",sprintf("optstring=\"%s\",pi=%u",	\
	optstring,pi))
    if (optstring ~ /^\+/) {		## OPSTRING has leading '+'?
	if (!compatible) ++posixly	## Yes, force POSIX compliancy (unless
	sub(/^./,"",optstring)		## in compatibility mode) and consume
					## leading '+'.
	trace(sprintf("posixly=%u;optstring=\"%s\"",posixly,optstring))
    } else if (optstring ~ /^-/) {	## OPSTRING has leading '-'?
	if (!compatible) ++ordered	## Yes, force output ordering (unless
	sub(/^./,"",optstring)		## in compatibility mode) and consume
					## leading '-'.
	trace(sprintf("ordered=%u;optstring=\"%s\"",ordered,optstring))
    }

    re = compatible ? "^.:?:?" : "^[^-:]:?:?"
					## Choose short option descriptor RE.
    while (optstring) {			## While OPTSTRING is not empty do...
	if (!match(optstring,re)) {	## Looking at valid descriptor?
	    error(sprintf("'%s' describes no short option!",optstring),pi)
	    leave("1"); return 1	## No, complain and indicate failure!
	}
	ow = substr(optstring,1,1); on = "-" ow; at = dl2at[RLENGTH]
	trace(sprintf("ow=\"%s\";on=\"%s\";at=%s",ow,on,at2sy[at]))
					## Derive option word, name, and
					## type from descriptor.
	if (!(oi = pion2oi[pi,on])) {	## Short option unregistered so far?
	    pioi2on[pi,oi = pion2oi[pi,on] = ++pi2oc[pi]] = on
	    pioi2at[pi,oi] = at		## Yes, register short option.
	    trace(sprintf("pioi2on[pi=%u,oi=pion2oi[pi,on]=++pi2oc[pi]"	\
		"=%u]=on;pioi2at[pi,oi]=at",pi,oi))
	} else if (at != pioi2at[pi,oi]) {
					## No, and registered differently?
	    error(sprintf("'%s' already registered by '%s%s'!",on,ow,	\
		at2ds[pioi2at[pi,oi]]),pi)
	    leave("1"); return 1	## Yes, complain and indicate failure!
	}
	optstring = substr(optstring,1+RLENGTH)
	trace(sprintf("optstring=\"%s\"",optstring))
    }					## Consume descriptor.
    leave("0"); return 0		## Indicate success.
}

##----------------------------------------------------------------------------
##  getopt_add_longopts(LONGOPTS,PI)
##				Add long options described by LONGOPTS's to
##				PI-th pass
##  Global variables:
##	- RSTART	(W) match() start position
##	- RLENGTH	(W) match() length
##	- at2sy[AT]	(R) Argument type -> symbol map
##	- dl2at[DL]	(R) Short option descriptor's length -> type map
##	- at2ds[AT]	(R) Option type -> descriptor suffix map
##	- pi2oc[PI]	(W) Per-pass option index -> name map's size
##	- pion2oi[PI,ON](W) Per-pass option name -> index map
##	- pioi2on[PI,OI](W) Per-pass option index -> name map
##	- pioi2at[PI,OI](W) Per-pass option index -> type map
##  Local variables:
##	- di		(W) Descriptor index
##	- dc		(R) Descriptor count
##	- dv[DI]	(R) Descriptor vector
##	- cp		(W) ':' position/abbreviation length
##	- ow		(W) Option word
##	- on		(W) Option name
##	- at		(W) Option type
##	- oi		(W) Option index
##----------------------------------------------------------------------------
function getopt_add_longopts(longopts,pi ,di,dc,dv,cp,ow,on,at,oi) {
    enter("getopt_add_longopts",sprintf("longopts=\"%s\",pi=%u",longopts,pi))
    di = 0; dc = split(longopts,dv,/,/)	## Split LONGOPTS into descriptors.
    while (++di <= dc) {		## Foreach descriptor do...
	if (!match(dv[di],/^[^-=:]+(-[^-=:]+)*:?:?$/)) {
					## Description is valid?
	    error(sprintf("'%s' describes no long option!",dv[di]),pi)
	    leave("1"); return 1	## No, complain and indicate failure!
	}
	if (!(cp = index(dv[di],":"))) cp = RLENGTH + 1
	ow = substr(dv[di],1,cp-1); on = "--" ow; at = dl2at[2+RLENGTH-cp]
	trace(sprintf("ow=\"%s\";on=\"%s\";at=%s",ow,on,at2sy[at]))
					## Derive colon position as well as
					## option word, name, and type from
					## descriptor.
	if (!(oi = pion2oi[pi,on]) || (on < pioi2on[pi,oi])) {
					## Long option so far unregistered or
					## registered as abbreviation?
	    pioi2on[pi,oi = pion2oi[pi,on] = ++pi2oc[pi]] = on
	    pioi2at[pi,oi] = at		## Yes, register long option.
	    trace(sprintf("pioi2on[pi=%u,oi=pion2oi[pi,on]=++pi2oc[pi]"	\
		"=%u]=on;pioi2at[pi,oi]=at",pi,oi))
	} else if (at != pioi2at[pi,oi]) {
					## No, and registered differently?
	    error(sprintf("'%s' already registered by '%s%s'!",on,ow,	\
		at2ds[pioi2at[pi,oi]]),pi)
	    leave("1"); return 1	## Yes, complain and indicate failure!
	}

	while (cp > 2) {		## Foreach abbreviation do...
	    if (!pion2oi[pi,on = substr(on,1,cp--)]) {
					## Abbreviation already registered?
		pion2oi[pi,on] = oi	## No, register abbreviation.
		trace(sprintf("pion2oi[pi=%u,on=\"%s\"]=%u",pi,on,oi))
	    } else if ((oi = pion2oi[pi,on]) < 0) {
					## Abbreviation already ambiguous?
		break			## Yes, so its prefices are, too!
	    } else if (pioi2on[pi,oi] != on) {
					## Abbreviation is ambiguous?
		pion2oi[pi,on] = -1	## Yes, indicate so.
		trace(sprintf("pion2oi[pi=%u,on=\"%s\"]=-1",pi,on))
	    }
	}
    }
    leave("0"); return 0		## Indicate success.
}

##----------------------------------------------------------------------------
##  unshift(ARG)		Unfetch ARGument
##
##  Global variables:
##	- ARGI		(W) Argument index
##	- ARGV[ARGI]	(W) Argument vector
##----------------------------------------------------------------------------
function unshift(arg) {
    ARGV[--ARGI] = arg; trace(sprintf("ARGV[--ARGI=%u]=arg",ARGI))
}

##----------------------------------------------------------------------------
##  getopt_shift(PI)		Fetch next option/argument in PI-th pass
##
##  Global variables:
##	- ARGC		(R) Argument count
##	- RSTART	(W) match() start position
##	- RLENGTH	(W) match() length
##	- OPTNAM	(W) Parsed option name
##	- OPTVAL	(W) Parsed option value
##	- at2sy[AT]	(R) Argument type -> symbol map
##	- pion2oi[PI,ON](W) Per-pass option name -> index map
##	- pioi2on[PI,OI](W) Per-pass option index -> name map
##	- pioi2at[PI,OI](W) Per-pass option index -> type map
##  Local variables:
##	- arg		(W) Fetched argument
##	- on		(W) Option name
##	- ov		(W) Option value
##	- oi		(W) Option index
##	- at		(W) Fetched argument's type
##	- ep		(W) '=' position
##----------------------------------------------------------------------------
function getopt_shift(pi ,arg,on,ov,oi,at,ep) {
    enter("getopt_shift",sprintf("pi=%u",pi))
    if (ARGI < ARGC) {			## Arguments remain?
	arg = ARGV[ARGI++]; trace(sprintf("arg=\"%s\"",arg))
    } else {				## Yes, fetch next argument.
	leave(at2sy[AT_EOA]); return AT_EOA
    }					## No, indicate exhaustion!

    if (match(arg,/^-[^-]/)) {		## Looking at short option?
	on = substr(arg,RSTART,RLENGTH)	## Yes, split it into name and value.
	trace(sprintf("on=\"%s\"",on))
	ov = substr(arg,RSTART+RLENGTH)
	if (oi = pion2oi[pi,on]) {	## Registered for PI-th pass?
	    at = pioi2at[pi,oi]		## Yes, fetch argument type.
	    if (ov) {			## Value is "glued" to name?
		if (at >= AT_OOA) {	## Yes, and option wants value?
		    at = AT_ORA		## Yes, supply it.
		} else {
		    unshift("-" ov)	## No, push glued short options back.
		}
	    } else {			## No value "glued" to name!
		if (at <= AT_OOA) {	## Option requires value?
		    at = AT_ONA		## No, don't supply it.
		} else if (ARGI < ARGC) {
					## Arguments remain?
		    ov = ARGV[ARGI++]	## Yes, fetch value.
		    trace(sprintf("ov=\"%s\"",ov))
		} else {
		    error(sprintf("%s: missing value!",on),pi)
		    leave(at2sy[AT_ERR]); return AT_ERR
		}			## No, complain and indicate failure!
	    }
	    trace(sprintf("OPTNAM=\"%s\";OPTVAL=\"%s\"",on,ov))
	    leave(at2sy[at]); OPTNAM = on; OPTVAL = ov; return at
	} else if (!piow2ov[pi,"a"] || (arg !~ /^(-[^-=]+)+/)) {
					## Alternative long options allowed
					## and option looks like such?
	    error(sprintf("%s: unknown option!",on),pi)
	    leave(at2sy[AT_ERR]); return AT_ERR
	}				## No, complain and indicate failure!
	arg = "-" arg			## Fake long option.
	trace(sprintf("arg=\"%s\"",arg))
    }
    if (match(arg,/^-(-[^-=]+)+/)) {	## Looking at long option?
	on = substr(arg,RSTART,RLENGTH)	## Yes, identify name.
	trace(sprintf("on=\"%s\"",on))
	if (!(oi = pion2oi[pi,on])) {	## Registered for PI-th pass?
	    error(sprintf("%s: unknown option!",on),pi)
	    leave(at2sy[AT_ERR]); return AT_ERR
					## No, complain and indicate failure!
	} else if (oi < 0) {		## Unambiguous?
	    error(sprintf("%s: ambiguous option!",on),pi)
	    leave(at2sy[AT_ERR]); return AT_ERR
	}				## No, complain and indicate failure!
	at = pioi2at[pi,oi]		## Fetch argument type and full name.
	on = pioi2on[pi,oi]
	if (ep = index(arg,"=")) {	## Value is "glued" to name?
	    if (at >= AT_OOA) {		## Yes, and option wants value?
		at = AT_ORA; ov = substr(arg,ep+1)
	    } else {			## Yes, supply it.
		error(sprintf("%s: excess value (ignored).",on),pi)
	    }				## No, warn about excess value.
	} else {			## No value "glued" to name!
	    if (at <= AT_OOA) {		## Option requires value?
		at = AT_ONA		## No, don't supply it.
	    } else if (ARGI < ARGC) {	## Yes, and arguments remain?
		ov = ARGV[ARGI++]	## Yes, fetch value.
		trace(sprintf("ov=\"%s\"",ov))
	    } else {
		error(sprintf("%s: missing value!",on),pi)
		leave(at2sy[AT_ERR]); return AT_ERR
	    }				## No, complain and indicate failure!
	}
	trace(sprintf("OPTNAM=\"%s\";OPTVAL=\"%s\"",on,ov))
	leave(at2sy[at]); OPTNAM = on; OPTVAL = ov; return at
    }
    if (arg == "--") {			## Looking at end-of-option marker?
	leave(at2sy[AT_EOO]); return AT_EOO
    }					## Yes, consume and return it.
    leave(at2sy[AT_ARG]); return AT_ARG
}

##----------------------------------------------------------------------------
##  args_print()		Print command line parameters
##
##  Global variables:
##	- ARGC		(R) Argument count
##	- ARGI		(W) Argument index
##	- ARGV[ARGI]	(R) Argument vector
##----------------------------------------------------------------------------
function args_print() {
    for (ARGI = 0; ARGI < ARGC; ++ARGI)	## Foreach argument do...
	printf "ARGV[%u]=\"%s\"\n",ARGI,ARGV[ARGI]
					## Print it.
    printf "ARGC=%u\n",ARGC; return 0	## Print argument count.
}

##----------------------------------------------------------------------------
##  args_getopt(CN)		Emulate getopt(1)
##
##  Global variables:
##	- compatible	(W) Compatibility mode flag
##	- posixly	(W) POSIX compliancy flag
##	- ordered	(R) Ordered output flag
##	- piow2ov[PI,"n"]
##			(W) Per-pass command name
##	- piow2ov[PI,"u"]
##			(W) Per-pass unquoted output flag
##	- piow2ov[PI,"a"]
##			(W) Per-pass alternative long options flag
##	- piow2ov[PI,"o"]
##			(W) Per-pass OPTSTRING count
##	- piow2ov[PI,"q"]
##			(W) Per-pass quiet flag
##	- piow2ov[PI,"Q"]
##			(W) Per-pass suppress output flag
##	- piow2ov[PI,"s"]
##			(W) Per-pass shell
##	- OPTNAM	(R) Option name  parsed by getopt_shift()
##	- OPTVAL	(R) Option value parsed by getopt_shift()
##  Local variables:
##	- pi		(W) Pass index (1st pass processes getopt(1) options,
##					2nd pass processes invoker's options
##					and emits result)
##	- at		(W) Argument type returned by getopt_shift()
##	- ac		(W) Argument count (used in POSIX-compliant mode)
##	- O		(W) Result's  left-hand side (LHS)
##	- A		(W) Result's right-hand side (RHS)
##
##  TODO:   (1)	getopt(1) option '-h|--help' so far doesn't show usage.
##	    (2) getopt_shift() turns out to be a kludge (particularly with re-
##		gard to non-option argument handling). It'd better be merged
##		with this function to ultimately attain full compatibility
##		with util-linux's getopt(1).
##----------------------------------------------------------------------------
function args_getopt(cn ,pi,at,ac,O,A) {
    enter("args_getopt",sprintf("cn=\"%s\"",cn))
    pi = 1				## Enter 1st pass.
    piow2ov[pi+1,"n"] = piow2ov[pi,"n"] = cn
    trace(sprintf("piow2ov[pi=%u,\"n\"]=piow2ov[pi=%u,\"n\"]=\"%s\"",	\
	pi+1,pi,cn))			## Preset pass' command name.

    if ("POSIXLY_CORRECT" in ENVIRON) {	## POSIXLY_CORRECT present in env.?
	trace(sprintf("++posixly=%u",++posixly))
    }					## Yes, force POSIX compliancy.

    if ("GETOPT_COMPATIBLE" in ENVIRON) {
					## GETOPT_COMPATIBLE present in env.?
	trace(sprintf("++compatible=%u;++piow2ov[pi=%u,\"u\"]=%u",	\
	    ++compatible,pi+1,++piow2ov[pi+1,"u"]))
					## Yes, force compatibility mode and
					## imply unquoted output.
    } else if (   getopt_add_optstring("ahl:n:o:qQs:uTV",pi)		\
	       || getopt_add_longopts("alternative,help,longoptions:,"	\
		    "name:,options:,quiet,quiet-output,shell:,unquoted,"\
		    "test,version",pi)) {
					## Added own options for 1st pass?
	leave("3"); return 3		## No, indicate internal error!
    }

    for (;;) {				## While in 1st pass do...
	if (compatible || ((at = getopt_shift(pi)) < AT_ARG)) {
					## In compatibility mode or
					## 1st pass's options consumed?
	    trace("break"); break	## Yes, leave 1st pass.
	} else if (at == AT_ARG) {	## No, saw (non-option) argument?
	    trace(sprintf("--ARGI=%u;break",--ARGI)); break
					## Yes, back argument index up and
					## leave 1st pass.
	} else if (OPTNAM ~ /^(-h|--help)$/) {
					## No, saw option '-h|--help'?
	    ## show help		## Yes, show help and...
	    leave("2"); return 2	## ...indicate usage error!
	} else if (OPTNAM ~ /^(-V|--version)$/) {
					## No, saw option '-V|--version'?
	    printf "%s (%s) %s\n",cn,"@PACKAGE_NAME@","@PACKAGE_VERSION@"
					## Yes, show version and...
	    leave("0"); return 0	## ...indicate success.
	} else if (OPTNAM ~ /^(-T|--test)$/) {
					## No, saw option '-V|--version'?
	    leave("4"); return 4	## Yes, indicate modern getopt(1).
	} else if (OPTNAM ~ /^(-a|--alternative)$/) {
					## No, saw option '-a|--alternative'?
	    trace(sprintf("++piow2ov[pi=%u,\"a\"]=%u",pi+1,		\
		++piow2ov[pi+1,"a"]))	## Yes, allow alternative long options
					## in 2nd pass.
	} else if (OPTNAM ~ /^(-l|--longoptions)$/) {
					## No, saw option '-l|--longoptions'?
	    if (getopt_add_longopts(OPTVAL,pi+1)) {
					## Yes, 2nd pass's LONGOPTS added?
		leave("3"); return 3	## No, indicate internal error!
	    }
	} else if (OPTNAM ~ /^(-n|--name)$/) {
					## No, saw option '-n|--name'?
	    trace(sprintf("piow2ov[pi=%u,\"n\"]=\"%s\"",pi+1,		\
		piow2ov[pi+1,"n"] = OPTVAL))
					## Yes, set 2nd pass's command name.
	} else if (OPTNAM ~ /^(-o|--options)$/) {
					## No, saw option '-o|--options'?
	    if (getopt_add_optstring(OPTVAL,pi+1)) {
					## Yes, 2nd pass's OPTSTRING added?
		leave("3"); return 3	## No, indicate internal error!
	    }
	    trace(sprintf("++piow2ov[pi=%u,\"o\"]=%u",pi+1,		\
		++piow2ov[pi+1,"o"]))	## Count OPTSTRING occurence.
	} else if (OPTNAM ~ /^(-q|--quiet)$/) {
					## No, saw option '-q|--quiet'?
	    trace(sprintf("++piow2ov[pi=%u,\"q\"]=%u",pi+1,		\
		++piow2ov[pi+1,"q"]))	## Yes, make 2nd pass quiet.
	} else if (OPTNAM ~ /^(-Q|--quiet-output)$/) {
					## No, saw option '-Q|--quiet-output'?
	    trace(sprintf("++piow2ov[pi=%u,\"Q\"]=%u",pi+1,		\
		++piow2ov[pi+1,"Q"]))	## Yes, make 2nd pass entirely quiet.
	} else if (OPTNAM ~ /^(-s|--shell)$/) {
					## No, saw option '-s|--shell'?
	    if (OPTVAL ~ /^([bd]?a|k|t?c)?sh$/) {
					## Yes. Valid shell specified?
		trace(sprintf("piow2ov[pi=%u,\"s\"]=\"%s\"",pi+1,	\
		    piow2ov[pi+1,"s"] = OPTVAL))
					## Yes, set 2nd pass's shell.
	    } else {
		error(sprintf("invalid shell '%s'!",OPTVAL),pi)
	    }
	} else if (OPTNAM ~ /^(-u|--unquoted)$/) {
					## No, saw option '-u|--unquoted'?
	    trace(sprintf("++piow2ov[pi=%u,\"u\"]=%u",pi+1,		\
		++piow2ov[pi+1,"u"]))	## Yes, don't quote 2nd pass's output.
	}
    }

    if (at < AT_EOA) {			## Prior getopt_shift() failed?
	leave("1"); return 1		## Yes, indicate failure!
    } else if (!piow2ov[pi+1,"o"]) {	## Saw OPTSTRING for 2nd pass?
	if (ARGI < ARGC) {		## No, but arguments remain?
	    if (!compatible && (ARGI == 2)) {
					## Not in compatibility mode and OPT-
					## STRING is 1st argument?
		trace(sprintf("++compatible=%u;++piow2ov[pi=%u,\"u\"]"	\
		    "=%u",++compatible,pi+1,++piow2ov[pi+1,"u"]))
					## Yes, force compatibility mode and
	    }				## imply unquoted output.
	    if (!getopt_add_optstring(ARGV[ARGI++],pi+1)) {
					## Yes, 2nd pass's OPTSTRING added?
		trace(sprintf("++piow2ov[pi=%u,\"o\"]=%u",pi+1,		\
		    ++piow2ov[pi+1,"o"]))
					## Yes, count OPTSTRING occurence.
	    } else {
		leave("3"); return 3	## No, indicate internal error!
	    }
	} else if (!compatible) {	## No. In compatibility mode?
	    error("missing OPTSTRING!",pi)
	    leave("2"); return 2	## No, indicate usage error!
	}
    }

    trace(sprintf("++pi=%u;ac=%u",++pi,ac = 0))
					## Enter 2nd pass.
    for (;;) {				## While in 2nd pass do...
	if ((at = getopt_shift(pi)) < AT_ARG) {
					## 2nd pass's options consumed?
	    trace("break"); break	## Yes, leave 2nd pass.
	} else if (at == AT_ARG) {	## Saw (non-option) argument?
	    trace(sprintf("--ARGI=%u",--ARGI))
					## Yes, back argument index up.
	    if (posixly) {		## In POSIX-compliant mode?
		trace(sprintf("++ac=%u",++ac))
	    }				## Yes, count argument.
	    if (ordered) {		## Output is ordered?
		O = O quote_sh(ARGV[ARGI++],pi) " "
		trace(sprintf("O=\"%s\"",O))
					## Yes, fetch, quote, and append it
	    } else {			## to LHS.
		A = A " " quote_sh(ARGV[ARGI++],pi)
		trace(sprintf("A=\"%s\"",A))
					## No, fetch, quote, and append it
	    }				## to RHS.
	} else if (at == AT_ONA) {	## Saw option without value?
	    if (ordered || !ac) {	## Yes. Output is ordered or no argu-
					## ment seen in POSIX-compliant mode?
		O = O quote_sh(OPTNAM,pi) " "
		trace(sprintf("O=\"%s\"",O))
	    } else {			## Yes, quote and append it to LHS.
		A = A " " quote_sh(OPTNAM,pi)
		trace(sprintf("A=\"%s\"",A))
					## No, quote and append it to RHS
	    }				## (as if it were an argument).
	} else {			## Saw option with value!
	    if (ordered || !ac) {	## Output is ordered or no argument
					## seen in POSIX-compliant mode?
		O = O quote_sh(OPTNAM,pi) " " quote_sh(OPTVAL,pi) " "
		trace(sprintf("O=\"%s\"",O))
					## Yes, quote and append it as well as
	    } else {			## its value to LHS.
		A = A " " quote_sh(OPTNAM,pi) " " quote_sh(OPTVAL,pi)
		trace(sprintf("A=\"%s\"",A))
					## No, quote and append it as well as
					## its value to RHS (as if it were ar-
	    }				## guments).
	}
    }

    if (at < AT_EOA) {			## Prior getopt_shift() failed?
	leave("1"); return 1		## Yes, indicate failure!
    }
    while (ARGI < ARGC) {		## Foreach remaining argument do...
	A = A " " quote_sh(ARGV[ARGI++],pi)
	trace(sprintf("A=\"%s\"",A))	## Fetch, quote, and append it to RHS.
    }
    if (!piow2ov[pi,"Q"]) printf "%s--%s\n",O,A
					## Print result unless entirely quiet.
    leave("0"); return 0		## Indicate success.
}

##----------------------------------------------------------------------------
##  Main program:
##----------------------------------------------------------------------------
BEGIN {
    if (ARGV[ARGI=1] == "print") {	## Which action?
	args_print()			## Print arguments.
    } else if (ARGV[ARGI] == "getopt") {
	args_getopt(ARGV[ARGI])		## Emulate getopt(1).
    } else {
	printf "%s: unknown action '%s'!\n",
	    piow2ov[pi,"n"],ARGV[ARGI] | stderr
    }
}
